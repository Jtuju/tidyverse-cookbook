[
["index.html", "The Tidyverse Cookbook Welcome Legal disclaimer", " The Tidyverse Cookbook Edited by Garrett Grolemund 2018-12-05 Welcome This book is an R community project, and it wouldn’t be nearly as good without your help. There are a number of ways you can contribute, from spotting typos to adding recipes. Read How to Contribute to get started. This book collects code recipes for doing data science with R’s tidyverse. Each recipe solves a single common task, with a minimum of discussion. Everything in this book is licensed under the permissive Creative Commons 4.0 International License. We encourage you to reuse and adapt the recipes. Legal disclaimer I believe that each recipe in this book works as advertised, but be aware that the recipes come with the same warranty as R: ABSOLUTELY NO WARRANTY. The online version of this book is licensed under the Creative Commons 4.0 International License. "],
["how-to-contribute.html", "How to contribute", " How to contribute Please help us improve this book. Here are some ways to join the fun: Proofread - If something does not work, please let me know. Your vigilence is valuable! Vote on which recipes to add next - Visit the github issue tracker and upvote the recipes that you would like someone to write. Suggest a recipe - Propose new recipes on the github issue tracker. To propose a recipe, visit the tracker and then: Check that your recipe has not been proposed already. You’ll know if it has because proposed recipes will appear in the list of open issues. If your recipe has already been requested, upvote it. Click New Issue and then write and save your proposal. To help us write the recipe please: Make your request very specific. Each recipe should focus on one single, simple task. No homework problems please. Include the recipe template below. Don’t forget to change the TITLE and to complete the “You want to” sentence. This template will be the beginning of the finished recipe. ## TITLE You want to #### Solution {-} #### Discussion {-} Write a recipe or fix a typo - If you would like to add a recipe, or if you spot a typo, feel free to edit the underlying page and send a pull request. If you’ve never done this before, the process is very easy: Click the edit icon in the header at the top of this page. Make the changes using github’s in-page editor and save. If your changes add a recipe that has been proposed in the github issue tracker, add the phrase Fixes # and then the number of the issue that proposes the recipe. This will close the issue when your recipe is accepted. Submit a pull request and include a brief description of your changes. “Fixing typos” is perfectly adequate. If you add a recipe or make significant changes, include this phrase in your pull request message: CC BY 4.0. This applies the Creative Commons 4.0 International License to your contribution, which helps provide a uniform copyright for the entire book. You can begin a recipe by copying and pasting the following template: ## TITLE You want to #### Solution {-} #### Discussion {-} Keep in mind that your solution code must run. When you write the recipe, assume that the user has run library(&quot;tidyverse&quot;) and nothing else. Where possible, try to minimize additional package dependencies. A useful way to do this is to use data that comes in a tidyverse package. Here are the tidyverse data sets and the packages you’ll find them in. # data frames (tibbles) dplyr::band_instruments dplyr::band_instruments2 dplyr::band_members dplyr::starwars dplyr::storms forcats::gss_cat ggplot2::diamonds ggplot2::economics ggplot2::economics_long ggplot2::faithfuld ggplot2::midwest ggplot2::mpg ggplot2::msleep ggplot2::presidential ggplot2::seals ggplot2::txhousing modelr::heights modelr::sim1 modelr::sim2 modelr::sim3 modelr::sim4 tidyr::population tidyr::smiths tidyr::table1 tidyr::table2 tidyr::table3 tidyr::table4a tidyr::table4b tidyr::table5 tidyr::who # data frames (non-tibbles) ggplot2::luv_colours lubridate::lakers # arrays dplyr::nasa # character vectors stringr::fruit stringr::sentences stringr::words "],
["how-to-use-this-book.html", "How to use this book 0.1 How to get help 0.2 Vocab 0.3 What is the tidyverse?", " How to use this book The recipes in this book are organized according to the model of data science presented in R for Data Science. When you do data science, you find yourself repeating the same sequence of steps: I’ve grouped the recipes by task with the exception of Transform, which is split into chapters based on the type of data or structure to transform. To drill down to a recipe, click on one of the task names in the sidebar. If you are new to R, begin with Program, which will show you how to install the tidyverse. To save space, each recipe assumes that you have already run library(&quot;tidyverse&quot;). If additional library() calls are required, they will appear in the recipe. 0.1 How to get help R comes with a built in reference manual, which is fondly (but inaccurately) called R’s help pages. You can use R’s help pages to glean details that I do not cover here. To access the help page for an R function, type a ? at the command line followed by the function name, and then run the result, e.g. ?mutate If a function comes in an R package, you will need to load the package with library() before you access the function’s help page. Alternatively, you can access the help page by typing a ? followed by the package name, followed by ::, followed by the function name, e.g. ?dplyr::mutate 0.2 Vocab In R, it is difficult to distinguish between vectors that are lists and vectors that are not lists. Whenever the difference matters, I’ll call the first set of vectors lists and the second set data vectors. This seems sensible because non-list vectors are used to store data: every piece of data is stored in one. In turn, a data vector may be stored in a list or a data frame. Data vectors include atomic vectors but also include modified atomic vectors like factors and date-times. 0.3 What is the tidyverse? Each of the recipes in this book relies on R’s tidyverse, which is a collection of packages, functions, and ideas. You do not need to know which ideas are in the tidyverse to use tidyverse functions, just as you do not need to know which ingredients are in a cake mix to make a cake. But understanding the tidyverse will help you see the best practices embedded in each recipe. This will make it easier for you to adapt the recipes to your own work. The tidyverse is a collection of R packages designed for data science. Tidyverse packages share a common design philosophy, so when you learn how to use one tidyverse package, you learn a lot about how to use the others. Tidyverse packages are also: optimised to run fast, relying on C++ under the hood maintained by a paid staff of talented developers unusually well documented, see tidyverse.org and R for Data Science as examples. Install the complete set of tidyverse packages with: install.packages(&quot;tidyverse&quot;) 0.3.1 Tidy data Each package in the tidyverse is designed to use and return tidy data whenever appropriate. Tidy data is tabular data organized so that: Each column contains a single variable Each row contains a single observation In practice, tidy data in R appears as data frames or tibbles. A tibble is an enhanced version of a data frame that is easier to view at the command line. R treats tibbles like data frames in almost every other respect, because tibbles are a subclass of data frame. Tidy tibbles act as a common data structure that tidyverse functions use to talk to each other. Tidy data has other advantages as well. Tidy data aligns with R’s native data structure, the data frame; and tidy data is easy to use with R’s fast, built in vectorized operations. You can think of tidy data as the data format optimized for R. 0.3.2 Tidy tools Each package in the tidyverse also provides tidy tools. Tidy tools are R functions that: Accept and return the same type of data structure (as input and output) Focus on one task per function Can be combined with other functions to perform multi-step operations (using the pipe operator, %&gt;%) Tidy tools ensure that tidyverse packages are easy for you to use. If tidy data is the data format optimised for R, tidy tools are the function format optimised for R users. If you’d like to develop a deeper understanding of the tidyverse, I encourage you to read R for Data Science, or to work through the free tutorials on RStudio Cloud. "],
["program.html", "1 Program What you should know before you begin 1.1 Install a tidyverse package 1.2 Install all of the tidyverse packages 1.3 Load a single tidyverse package 1.4 Load the core set of tidyverse packages 1.5 Update a tidyverse package 1.6 Check that all of your tidyverse packages are up-to-date 1.7 List every package in the tidyverse 1.8 Combine functions into a pipe 1.9 Pipe a result to a specific argument", " 1 Program To manipulate vectors with purrr, see [Transform Lists]. Install a tidyverse package Install all of the tidyverse packages Load a single tidyverse package Load the core set of tidyverse packages Update a tidyverse package Check that all of your tidyverse packages are up-to-date List every package in the tidyverse Combine functions into a pipe Pipe a result to a specific argument What you should know before you begin An R package is a bundle of functions, documentation, and data sets. R has over 13,000 packages. These are not installed with R, but are archived online for when you need them. The tidyverse is a collection of R packages that are designed to work well together. There are about 25 packages in the tidyverse. To use an R package, you must: Install the package on your local machine with install.packages(). You only need to do this once per machine. Load the package with library(). You need to do this each time you start a new R session (if you wish to use the package in that session). You cannot use the contents of a package until you load the package in your current R session. You should update your packages from time to time to receive the latest improvements from package authors. Tidyverse functions are designed to be used with the %&gt;% operator. %&gt;% links R functions together to create a “pipe” of functions that are run in sequence: %&gt;% passes the output of one function to the input of the next. %&gt;% comes with the dplyr package, which imports it from the magrittr package. 1.1 Install a tidyverse package You’d like to install a package that is in the tidyverse. Solution install.packages(&quot;dplyr&quot;) Discussion Tidyverse packages can be installed in the normal way with install.packages(). See ?install.packages for installation details. By default, install.packages() will download packages from https://cran.r-project.org, or one of its mirrors—so be sure you are connected to the internet when you run it. 1.2 Install all of the tidyverse packages You’d like to install all of the packages in the tidyverse with a single command. Solution install.packages(&quot;tidyverse&quot;) Discussion The tidyverse package provides a shortcut for downloading all of the packages in the tidyverse. tidyverse purposefully lists each of the tidyverse packages as a dependency, which causes R to install all of the packages in the tidyverse when R installs tidyverse. install.packages(&quot;tidyverse&quot;) will install the following packages: ## [1] &quot;broom&quot; &quot;cli&quot; &quot;crayon&quot; &quot;dplyr&quot; &quot;dbplyr&quot; ## [6] &quot;forcats&quot; &quot;ggplot2&quot; &quot;haven&quot; &quot;hms&quot; &quot;httr&quot; ## [11] &quot;jsonlite&quot; &quot;lubridate&quot; &quot;magrittr&quot; &quot;modelr&quot; &quot;purrr&quot; ## [16] &quot;readr&quot; &quot;readxl\\n(&gt;=&quot; &quot;reprex&quot; &quot;rlang&quot; &quot;rstudioapi&quot; ## [21] &quot;rvest&quot; &quot;stringr&quot; &quot;tibble&quot; &quot;tidyr&quot; &quot;xml2&quot; ## [26] &quot;tidyverse&quot; 1.3 Load a single tidyverse package You want to load a package in the tidyverse that has been installed on your computer, so that you can use its contents. Solution library(&quot;dplyr&quot;) Discussion You can load individual tidyverse packages with library(). The package will stay loaded until you end your R session or run detach() on the package. If you begin a new R session, you will need to reload the package in the new session with library(). library() cannot load packages that have not been previously installed on your machine. 1.4 Load the core set of tidyverse packages You would like to load the most used tidyverse packages so you can use their contents. You’ve already installed these packages on your computer. Solution library(&quot;tidyverse&quot;) Discussion When you load the tidyverse package, R will also load the following packages: ggplot2 dplyr tidyr readr purrr tibble stringr forcats These eight packages are considered the “core” of the tidyverse because: They are the most used tidyverse packages. They are often used together as a set (when you use one of the packages, you tend to also use the others). You can still load each of these packages individually with library(). Notice that library(&quot;tidyverse&quot;) does not load every package installed by install.packages(&quot;tidyverse&quot;). You must use library() to individually load the “non-core” tidyverse packages. 1.5 Update a tidyverse package You want to ensure that you have the most up-to-date version of a package in the tidyverse installed on your machine. Solution update.packages(&quot;dplyr&quot;) Discussion update.packages() will compare the version number of the package that you have installed locally to the newest version number available on CRAN. If the version numbers do not match, update.packages() will download and install the newest version from CRAN. Be sure that you are connected to the internet when you run update.packages(). 1.6 Check that all of your tidyverse packages are up-to-date You want to ensure that you have the latest version of every tidyverse package. Solution tidyverse_update() Discussion tidyverse_update() checks whether or not each of your tidyverse packages is up-to-date. If every package is up-to-date, tidyverse_update() will return the message: All tidyverse packages up-to-date. Otherwise, tidyverse_update() will return a piece of code that you can copy and run to selectively update only those packages that are out-of-date. 1.7 List every package in the tidyverse You want to generate a vector that contains the names of every package in the tidyverse. Solution tidyverse_packages() ## [1] &quot;broom&quot; &quot;cli&quot; &quot;crayon&quot; &quot;dplyr&quot; &quot;dbplyr&quot; ## [6] &quot;forcats&quot; &quot;ggplot2&quot; &quot;haven&quot; &quot;hms&quot; &quot;httr&quot; ## [11] &quot;jsonlite&quot; &quot;lubridate&quot; &quot;magrittr&quot; &quot;modelr&quot; &quot;purrr&quot; ## [16] &quot;readr&quot; &quot;readxl\\n(&gt;=&quot; &quot;reprex&quot; &quot;rlang&quot; &quot;rstudioapi&quot; ## [21] &quot;rvest&quot; &quot;stringr&quot; &quot;tibble&quot; &quot;tidyr&quot; &quot;xml2&quot; ## [26] &quot;tidyverse&quot; Discussion tidyverse_packages() returns a vector with the names of every package that was in the tidyverse when you installed the tidyverse package. These are the packages that were installed onto your machine along with the tidyverse package. They are also the packages that tidyverse_update() will check. Update the tidyverse package before running tidyverse_packages() to receive the most current list. 1.8 Combine functions into a pipe You want to chain multiple functions together to be run in sequence, with each function operating on the preceeding function’s output. Solution starwars %&gt;% group_by(species) %&gt;% summarise(avg_height = mean(height, na.rm = TRUE)) %&gt;% arrange(avg_height) ## # A tibble: 38 x 2 ## species avg_height ## &lt;chr&gt; &lt;dbl&gt; ## 1 Yoda&#39;s species 66 ## 2 Aleena 79 ## 3 Ewok 88 ## 4 Vulptereen 94 ## 5 Dug 112 ## 6 Xexto 122 ## 7 Toydarian 137 ## 8 Droid 140 ## 9 Sullustan 160 ## 10 &lt;NA&gt; 160 ## # ... with 28 more rows Discussion The %&gt;% operator (pronounced “pipe operator”) evaluates the code on its left hand side (LHS) and then passes the result to the the code on its right hand side (RHS), which should be a function call. By default %&gt;% will pass the result of the LHS to the first unnamed argument of the function on the RHS. starwars %&gt;% group_by(species) is the equivalent of group_by(starwars, species), and the above solution is the equivalent of the nested code: arrange( summarise( group_by(starwars, species), avg_height = mean(height, na.rm = TRUE) ), avg_height ) or the equivalent of: x1 &lt;- starwars x2 &lt;- group_by(x1, species) x3 &lt;- summarise(x3, avg_height = mean(height, na.rm = TRUE)) arrange(x3, avg_height) The chunk of functions connected by %&gt;% is called a “pipe.” Pipes are easier to read than nested code (mentally pronounce %&gt;% as “then” to read the pipe as a sequence of steps). And pipes require fewer temporary objects than code that passes temporary objects from one function to the next. The %&gt;% operator is loaded with the dplyr package, which imports it from the magrittr package. Tidyverse functions facilitate using %&gt;% by accepting a data frame as their first argument returning a data frame as their result %&gt;% is easy to type in the RStudio IDE with the keyboard shortcuts Command + Shift + M (Mac OS) Control + Shift + M (Windows) 1.9 Pipe a result to a specific argument You want to use %&gt;% to pass the result of the left hand side to an argument that is not the first argument of the function on the right hand side. Solution starwars %&gt;% lm(mass ~ height, data = .) ## ## Call: ## lm(formula = mass ~ height, data = .) ## ## Coefficients: ## (Intercept) height ## -13.8103 0.6386 Discussion By default %&gt;% passes the result of the left hand side to the the first unnamed argument of the function on the right hand side. To override this default, use . as a placeholder within the function call on the right hand side. %&gt;% will evaluate . as the result of the left hand side, instead of passing the result to the first unnamed argument. The solution code is the equivalent of lm(mass ~ height, data = starwars) "],
["import.html", "2 Import What you should know before you begin 2.1 Import data quickly with a GUI", " 2 Import Import data quickly with a GUI What you should know before you begin Before you can manipulate data with R, you need to import the data into R’s memory, or build a connection that R can use to access the data remotely. How you import data will depend on the format in which the data is stored. The most common way to store small data sets is as a plain text file. Data may also be stored in a proprietary format associated with a specific piece of software, such as SAS, SPSS, or Microsoft Excel. Data collected from the internet is often stored as a JSON file. Large data sets may be stored in a database or a distributed storage system. R stores data in your computer’s RAM while you manipulate it. This creates a size limitation: truly big data sets should be stored outside of R in a database or distributed storage system that R can connect to to manipulate the data. 2.1 Import data quickly with a GUI You want to import data quickly, and you do not mind using a semi-reproducible graphical user interface (GUI) to do so. Solution Discussion The RStudio IDE provides an Import Dataset button in the Environment pane, which appears in the top right corner of the IDE by default. You can use this button to import data that is stored in plain text files as well as in Excel, SAS, SPSS, and Stata files. Click the button to launch a window that includes a file browser (below). Use the browser to select the file to import. After you’ve selected a file, RStudio will display a preview of how the file will be imported as a data frame. Below the preview, RStudio provides a GUI interface to the common options for importing the type of file you have selected. As you customize the options, RStudio updates the data preview to display the results. The bottom right-hand corner of the window displays the code that will reproduce your importation process programatically. You should copy and save this code if you wish to document your work in a reproducible workflow. "],
["tidy.html", "3 Tidy What you should know before you begin 3.1 Create a tibble manually 3.2 Convert a data frame to a tibble 3.3 Convert a tibble to a data frame 3.4 Preview the contents of a tibble 3.5 Inspect every cell of a tibble 3.6 Spread a pair of columns into a field of cells 3.7 Gather a field of cells into a pair of columns 3.8 Separate a column into new columns 3.9 Unite multiple columns into a single column", " 3 Tidy Create a tibble manually Convert a data frame to a tibble Convert a tibble to a data frame Preview the contents of a tibble Inspect every cell of a tibble Spread a pair of columns into a field of cells Gather a field of cells into a pair of columns Separate a column into new columns Unite multiple columns into a single column What you should know before you begin Data tidying refers to reshaping your data into a tidy data frame or tibble. Data tidying is an important first step for your analysis because every tidyverse function will expect your data to be stored as Tidy Data. Tidy data is tabular data organized so that: Each column contains a single variable Each row contains a single observation The definition of tidy data depends on the definition of variable, which is a quantity, quality, or property that you can measure. With enough mental flexibility, you can consider anything to be a variable (and use anything as a variable). However, some variables will be more useful than others for any specific task. In general, if you can formulate your task as an equation (math or code that contains an equals sign), the most useful variables will be the objects in the equation. Tidy data is not an arbitrary requirement of the tidyverse; it is the ideal data format for doing data science with R. Tidy data makes it easy to extract every value of a variable to build a plot or to compute a summary statistic. Tidy data also makes it easy to compute new variables; when your data is tidy, you can rely on R’s rowwise operations to maintain the integrity of your observations. Moreover, R can directly manipulate tidy data with R’s fast, built-in vectorised observations, which lets your code run as fast as possible. 3.1 Create a tibble manually You want to create a tibble from scratch by typing in the contents of the tibble. Solution tribble(~number, ~letter, ~greek, 1, &quot;a&quot;, &quot;alpha&quot;, 2, &quot;b&quot;, &quot;beta&quot;, 3, &quot;c&quot;, &quot;gamma&quot;) ## # A tibble: 3 x 3 ## number letter greek ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 a alpha ## 2 2 b beta ## 3 3 c gamma Discussion tribble() creates a tibble while generating a preview of the result in your code. To use tribble(), list each column name preceded by a ~, then list the values of the tribble in a rowwise fashion. If you take care to align your columns, the transposed syntax of tribble() becomes a preview of the table. You can also create a tibble with tibble(), whose syntax mirrors data.frame(): tibble(number = c(1, 2, 3), letter = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), greek = c(&quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;)) 3.2 Convert a data frame to a tibble You want to convert a data frame to a tibble. Solution as_tibble(iris) ## # A tibble: 150 x 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## 7 4.6 3.4 1.4 0.3 setosa ## 8 5 3.4 1.5 0.2 setosa ## 9 4.4 2.9 1.4 0.2 setosa ## 10 4.9 3.1 1.5 0.1 setosa ## # ... with 140 more rows 3.3 Convert a tibble to a data frame You want to convert a tibble to a data frame. Solution as.data.frame(table1) ## country year cases population ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 Discussion Be careful to use as.data.frame() and not as_data_frame(), which is an alias for as_tibble(). 3.4 Preview the contents of a tibble You want to get an idea of what variables and values are stored in a tibble. Solution storms ## # A tibble: 10,010 x 13 ## name year month day hour lat long status category wind pressure ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;ord&gt; &lt;int&gt; &lt;int&gt; ## 1 Amy 1975 6 27 0 27.5 -79 tropi… -1 25 1013 ## 2 Amy 1975 6 27 6 28.5 -79 tropi… -1 25 1013 ## 3 Amy 1975 6 27 12 29.5 -79 tropi… -1 25 1013 ## 4 Amy 1975 6 27 18 30.5 -79 tropi… -1 25 1013 ## 5 Amy 1975 6 28 0 31.5 -78.8 tropi… -1 25 1012 ## 6 Amy 1975 6 28 6 32.4 -78.7 tropi… -1 25 1012 ## 7 Amy 1975 6 28 12 33.3 -78 tropi… -1 25 1011 ## 8 Amy 1975 6 28 18 34 -77 tropi… -1 30 1006 ## 9 Amy 1975 6 29 0 34.4 -75.8 tropi… 0 35 1004 ## 10 Amy 1975 6 29 6 34 -74.8 tropi… 0 40 1002 ## # ... with 10,000 more rows, and 2 more variables: ts_diameter &lt;dbl&gt;, ## # hu_diameter &lt;dbl&gt; Discussion When you call a tibble directly, R will display enough information to give you a quick sense of the contents of the tibble. This includes: the dimensions of the tibble the column names and types as many cells of the tibble as will fit comfortably in your console window 3.5 Inspect every cell of a tibble You want to see which values are stored in a tibble. Solution View(storms) Discussion View() (with a capital V) opens the tibble in R’s data viewer, which will let you scroll to every cell in the tibble. 3.6 Spread a pair of columns into a field of cells You want to pivot, convert long data to wide, or move variable names out of the cells and into the column names. These are different ways of describing the same thing. For example, table2 contains type, which is a column that repeats the variable names case and population. To make table2 tidy, you must move case and population values into their own columns. table2 ## # A tibble: 12 x 4 ## country year type count ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 1999 cases 745 ## 2 Afghanistan 1999 population 19987071 ## 3 Afghanistan 2000 cases 2666 ## 4 Afghanistan 2000 population 20595360 ## 5 Brazil 1999 cases 37737 ## 6 Brazil 1999 population 172006362 ## 7 Brazil 2000 cases 80488 ## 8 Brazil 2000 population 174504898 ## 9 China 1999 cases 212258 ## 10 China 1999 population 1272915272 ## 11 China 2000 cases 213766 ## 12 China 2000 population 1280428583 Solution table2 %&gt;% spread(key = type, value = count) ## # A tibble: 6 x 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 Discussion To use spread(), assign the column that contains variable names to key. Assign the column that contains the values that are associated with those names to value. spread() will: Make a copy of the original table Remove the key and value columns from the copy Remove every duplicate row in the data set that remains Insert a new column for each unique variable name in the key column Fill the new columns with the values of the value column in a way that preserves each relationship between values in the original data set Each new column created by spread() will inherit the data type of the value column. If you would like spread() to convert each new column to the most sensible data type given its final contents, add the argument convert = TRUE. 3.7 Gather a field of cells into a pair of columns You want to convert wide data to long, reshape a two-by-two table, or move variable values out of the column names and into the cells. These are different ways of describing the same thing. For example, table4a is a two-by-two table with the column names 1999 and 2000. These names are values of a year variable. The field of cells in table4a contains counts of TB cases, which is another variable. To make table4a tidy, you need to move year and cases into their own columns. table4a ## # A tibble: 3 x 3 ## country `1999` `2000` ## * &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 745 2666 ## 2 Brazil 37737 80488 ## 3 China 212258 213766 Solution table4a %&gt;% gather(key = &quot;year&quot;, value = &quot;cases&quot;, 2:3) ## # A tibble: 6 x 3 ## country year cases ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 ## 2 Brazil 1999 37737 ## 3 China 1999 212258 ## 4 Afghanistan 2000 2666 ## 5 Brazil 2000 80488 ## 6 China 2000 213766 Discussion gather() is the inverse of spread(): gather() collapses a field of cells that spans several columns into two columns: A column of former “keys”, which contains the column names of the former field A column of former “values”, which contains the cell values of the former field To use gather(), pick names for the new key and value columns, and supply them as strings. Then identify the columns to gather into the new key and value columns. gather() will: Create a copy of the original table Remove the identified columns from the copy Add a key column with the supplied name Fill the key column with the column names of the removed columns, repeating rows as necessary so that each combination of row and removed column name appears once Add a value column with the supplied name Fill the value column with the values of the removed columns in a way that preserves each relationship between values and column names in the original data set You can identify the columns to remove by name, by index (number), by inverse index (negative number), or by any of the select() helpers, which come in the dplyr package. So for example, the following commands will do the same thing as the solution above: table4a %&gt;% gather(key = &quot;year&quot;, value = &quot;cases&quot;, `&quot;1999&quot;, &quot;2000&quot;) table4a %&gt;% gather(key = &quot;year&quot;, value = &quot;cases&quot;, -1) table4a %&gt;% gather(key = &quot;year&quot;, value = &quot;cases&quot;, one_of(c(&quot;1999&quot;, &quot;2000&quot;))) By default, the new key column will contain character strings. If you would like gather() to convert the new key column to the most sensible data type given its final contents, add the argument convert = TRUE. 3.8 Separate a column into new columns You want to split a single column into multiple columns by separating each cell in the column into a row of cells that each contain a separate portion of the value in the original cell. For example, table3 combines cases and population values in a single column named rate. To make table3 tidy, you need to separate rate into two columns: one for the cases variable, one for the population variable. table3 ## # A tibble: 6 x 3 ## country year rate ## * &lt;chr&gt; &lt;int&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745/19987071 ## 2 Afghanistan 2000 2666/20595360 ## 3 Brazil 1999 37737/172006362 ## 4 Brazil 2000 80488/174504898 ## 5 China 1999 212258/1272915272 ## 6 China 2000 213766/1280428583 Solution table3 %&gt;% separate(col = rate, into = c(&quot;cases&quot;, &quot;population&quot;), sep = &quot;/&quot;, convert = TRUE) ## # A tibble: 6 x 4 ## country year cases population ## * &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 Discussion To use separate(), pass col the name of the column to split. Pass into a vector of names for the new columns that col will be split into. You should supply one name for each new column that you expect to appear in the result; a mismatch will imply that something went wrong. separate() will: Create a copy of the original data set Add a new column for each name in into Split each value of col into multiple values. To do this, separate() will locate the positions of a separator character in each value. separate() will then makes the segments that appear between the separators separate (sub)values. Place the resulting (sub)values into the new columns in order, one (sub)value per column Remove the col column Add the argument remove = FALSE to retain the col column in the final result. By default, separate() will use each non-alpha-numeric character as a separator. To designate a specific separator character, pass a regular expression to sep. To split values into sequences that each have a specific number of characters, pass an integer vector to sep: sep = 1 will split each value between the first and second character. sep = c(1, 3) will split each value between the first and second character and then again between the third and fourth character. sep = -1 will split each value between the last and second to last character. Each new column created by separate() will inherit the data type of the col column. If you would like separate() to convert each new column to the most sensible data type given its final contents, add the argument convert = TRUE. 3.9 Unite multiple columns into a single column You want to combine several columns into a single column by uniting their values across rows. For example, table5 splits the year variable across two columns: century and year. To make table5 tidy, you need to unite century and year into a single column. table5 ## # A tibble: 6 x 4 ## country century year rate ## * &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 19 99 745/19987071 ## 2 Afghanistan 20 00 2666/20595360 ## 3 Brazil 19 99 37737/172006362 ## 4 Brazil 20 00 80488/174504898 ## 5 China 19 99 212258/1272915272 ## 6 China 20 00 213766/1280428583 Solution table5 %&gt;% unite(col = &quot;year&quot;, century, year, sep = &quot;&quot;) ## # A tibble: 6 x 3 ## country year rate ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745/19987071 ## 2 Afghanistan 2000 2666/20595360 ## 3 Brazil 1999 37737/172006362 ## 4 Brazil 2000 80488/174504898 ## 5 China 1999 212258/1272915272 ## 6 China 2000 213766/1280428583 Discussion To use unite(), give col a character string to use as the name of the new column to create. Then list the columns to combine, and give sep a separator character to use to paste together the values in the cells of each column. unite() will: Paste together the values of the listed columns in vectorized (i.e. rowwise) fashion. unite() will place sep between each value during the paste process. Append the result as a column named col to a copy of the original data set Remove the listed columns. To retain the columns in the result, add the argument remove = FALSE. If you do not suppy a sep value, unite() will use _ as a separator character. "],
["transform-tables.html", "4 Transform Tables What you should know before you begin 4.1 Arrange rows in ascending order by the values of a column 4.2 Arrange rows in descending order by the values of a column 4.3 Filter rows with a logical test 4.4 Select columns by name 4.5 Drop columns by name 4.6 Select a range of columns 4.7 Select columns by integer position 4.8 Select columns by start of name 4.9 Select columns by end of name 4.10 Select columns by string in name 4.11 Reorder columns 4.12 Reorder columns without naming all columns 4.13 Rename columns 4.14 Return the contents of a column as a vector 4.15 Summarise data 4.16 Summarise data by groups 4.17 Mutate data (Add new variables)", " 4 Transform Tables Arrange rows in ascending order by the values of a column Arrange rows in descending order by the values of a column Filter rows with a logical test Select columns by name Drop columns by name Select a range of columns Select columns by integer position Select columns by start of name Select columns by end of name Select columns by string in name Reorder columns Reorder columns without naming all columns Rename columns Return the contents of a column as a vector Summarise data Summarise data by groups Mutate data (Add new variables) [How to combine transform recipes] [Join data sets] [Filter one data set against another] What you should know before you begin Tidyverse functions that transform tables do not transform your original table, which is preserved in its original form under its original name. Tidyverse functions instead return a modified copy of the table, which can be passed to the next function in a pipe, or assigned to a name for later use. dplyr functions will match column names that appear within their arguments to columns in the data frame that they are manipulating. To avoid this behavior, place !! before a name to unquote it, e.g. !!model. Transforming a table sometimes requires more than one recipe. Why? Because tables are made of multiple data structures that work together: The table itself is a data frame or tibble. The columns of the table are vectors. Some columns may be list-columns, which are lists that contain vectors. This matters because one of the design philosophies of the tidyverse is that each function should focus on one task and do it well. Functions that do one task well tend to work with one type of data structure. So to transform a table, you often need to combine a function that manipulates tables with a function that manipulates data vectors and maybe a function that manipulates lists. See [Combine Transform Recipes] for tips. 4.1 Arrange rows in ascending order by the values of a column You want to sort the rows of a data frame in ascending order by the values in one or more columns. Solution mpg %&gt;% arrange(cty) ## # A tibble: 234 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl cla… ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;ch&gt; ## 1 dodge dako… 4.7 2008 8 auto… 4 9 12 e pic… ## 2 dodge dura… 4.7 2008 8 auto… 4 9 12 e suv ## 3 dodge ram … 4.7 2008 8 auto… 4 9 12 e pic… ## 4 dodge ram … 4.7 2008 8 manu… 4 9 12 e pic… ## 5 jeep gran… 4.7 2008 8 auto… 4 9 12 e suv ## 6 chevrolet c150… 5.3 2008 8 auto… r 11 15 e suv ## 7 chevrolet k150… 5.3 2008 8 auto… 4 11 14 e suv ## 8 chevrolet k150… 5.7 1999 8 auto… 4 11 15 r suv ## 9 dodge cara… 3.3 2008 6 auto… f 11 17 e min… ## 10 dodge dako… 5.2 1999 8 manu… 4 11 17 r pic… ## # ... with 224 more rows Discussion arrange() sorts the rows according to the values of the specified column, with the lowest values appearing near the top of the data frame. arrange() will use additional columns as tiebreakers to sort within rows that share the same value of the first column. mpg %&gt;% arrange(cty, hwy) ## # A tibble: 234 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl cla… ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;ch&gt; ## 1 dodge dako… 4.7 2008 8 auto… 4 9 12 e pic… ## 2 dodge dura… 4.7 2008 8 auto… 4 9 12 e suv ## 3 dodge ram … 4.7 2008 8 auto… 4 9 12 e pic… ## 4 dodge ram … 4.7 2008 8 manu… 4 9 12 e pic… ## 5 jeep gran… 4.7 2008 8 auto… 4 9 12 e suv ## 6 chevrolet k150… 5.3 2008 8 auto… 4 11 14 e suv ## 7 jeep gran… 6.1 2008 8 auto… 4 11 14 p suv ## 8 chevrolet c150… 5.3 2008 8 auto… r 11 15 e suv ## 9 chevrolet k150… 5.7 1999 8 auto… 4 11 15 r suv ## 10 dodge dako… 5.2 1999 8 auto… 4 11 15 r pic… ## # ... with 224 more rows 4.2 Arrange rows in descending order by the values of a column You want to sort the rows of a data frame in descending order by the values in one or more columns. Solution mpg %&gt;% arrange(desc(cty)) ## # A tibble: 234 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl cla… ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;ch&gt; ## 1 volkswagen new … 1.9 1999 4 manu… f 35 44 d sub… ## 2 volkswagen jetta 1.9 1999 4 manu… f 33 44 d com… ## 3 volkswagen new … 1.9 1999 4 auto… f 29 41 d sub… ## 4 honda civic 1.6 1999 4 manu… f 28 33 r sub… ## 5 toyota coro… 1.8 2008 4 manu… f 28 37 r com… ## 6 honda civic 1.8 2008 4 manu… f 26 34 r sub… ## 7 toyota coro… 1.8 1999 4 manu… f 26 35 r com… ## 8 toyota coro… 1.8 2008 4 auto… f 26 35 r com… ## 9 honda civic 1.6 1999 4 manu… f 25 32 r sub… ## 10 honda civic 1.8 2008 4 auto… f 25 36 r sub… ## # ... with 224 more rows Discussion Place desc() around a column name to cause arrange() to sort by descending values of that column. You can use desc() for tie-breaker columns as well. mpg %&gt;% arrange(cty, desc(hwy)) ## # A tibble: 234 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl cla… ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;ch&gt; ## 1 dodge dako… 4.7 2008 8 auto… 4 9 12 e pic… ## 2 dodge dura… 4.7 2008 8 auto… 4 9 12 e suv ## 3 dodge ram … 4.7 2008 8 auto… 4 9 12 e pic… ## 4 dodge ram … 4.7 2008 8 manu… 4 9 12 e pic… ## 5 jeep gran… 4.7 2008 8 auto… 4 9 12 e suv ## 6 dodge cara… 3.3 2008 6 auto… f 11 17 e min… ## 7 dodge dako… 5.2 1999 8 manu… 4 11 17 r pic… ## 8 ford expe… 4.6 1999 8 auto… r 11 17 r suv ## 9 ford expe… 5.4 1999 8 auto… r 11 17 r suv ## 10 lincoln navi… 5.4 1999 8 auto… r 11 17 r suv ## # ... with 224 more rows 4.3 Filter rows with a logical test You want to filter your table to just the rows that meet a specific condition. Solution mpg %&gt;% filter(model == &quot;jetta&quot;) ## # A tibble: 9 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 volkswagen jetta 1.9 1999 4 manu… f 33 44 d comp… ## 2 volkswagen jetta 2 1999 4 manu… f 21 29 r comp… ## 3 volkswagen jetta 2 1999 4 auto… f 19 26 r comp… ## 4 volkswagen jetta 2 2008 4 auto… f 22 29 p comp… ## 5 volkswagen jetta 2 2008 4 manu… f 21 29 p comp… ## 6 volkswagen jetta 2.5 2008 5 auto… f 21 29 r comp… ## 7 volkswagen jetta 2.5 2008 5 manu… f 21 29 r comp… ## 8 volkswagen jetta 2.8 1999 6 auto… f 16 23 r comp… ## 9 volkswagen jetta 2.8 1999 6 manu… f 17 24 r comp… Discussion filter() takes a logical test and returns the rows for which the logical test returns TRUE. filter() will match column names that appear within the logical test to columns in your data frame. filter() will combine multiple logical tests with an AND operator (&amp;): mpg %&gt;% filter(model == &quot;jetta&quot;, year == 1999) ## # A tibble: 5 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 volkswagen jetta 1.9 1999 4 manu… f 33 44 d comp… ## 2 volkswagen jetta 2 1999 4 manu… f 21 29 r comp… ## 3 volkswagen jetta 2 1999 4 auto… f 19 26 r comp… ## 4 volkswagen jetta 2.8 1999 6 auto… f 16 23 r comp… ## 5 volkswagen jetta 2.8 1999 6 manu… f 17 24 r comp… See ?Comparison and ?Logic to learn more about writing logical tests in R. 4.4 Select columns by name You want to return a “subset” of columns from your data frame by listing the name of each column to return. Solution table1 %&gt;% select(country, year, cases) ## # A tibble: 6 x 3 ## country year cases ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 ## 2 Afghanistan 2000 2666 ## 3 Brazil 1999 37737 ## 4 Brazil 2000 80488 ## 5 China 1999 212258 ## 6 China 2000 213766 Discussion select() returns a new data frame that includes each column passed to select(). Repeat a name to include the column twice. 4.5 Drop columns by name You want to return a “subset” of columns from your data frame by listing the name of each column to drop. Solution table1 %&gt;% select(-c(population, year)) ## # A tibble: 6 x 2 ## country cases ## &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 745 ## 2 Afghanistan 2666 ## 3 Brazil 37737 ## 4 Brazil 80488 ## 5 China 212258 ## 6 China 213766 Discussion If you use a - before a column name, select() will return every column in the data frame except that column. To drop more than one column at a time, group the columns into a vector preceded by -. 4.6 Select a range of columns You want to return two columns from a data frame as well as every column that appears between them. Solution table1 %&gt;% select(country:cases) ## # A tibble: 6 x 3 ## country year cases ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 ## 2 Afghanistan 2000 2666 ## 3 Brazil 1999 37737 ## 4 Brazil 2000 80488 ## 5 China 1999 212258 ## 6 China 2000 213766 Discussion If you combine two column names with a :, select() will return both columns and every column that appears between them in the data frame. 4.7 Select columns by integer position You want to return a “subset” of columns from your data frame by listing the position of each column to return. Solution table1 %&gt;% select(1, 2, 4) ## # A tibble: 6 x 3 ## country year population ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 19987071 ## 2 Afghanistan 2000 20595360 ## 3 Brazil 1999 172006362 ## 4 Brazil 2000 174504898 ## 5 China 1999 1272915272 ## 6 China 2000 1280428583 Discussion select() interprets the whole number n as the _n_th column in the data set. You can combine numbers with - and : inside of select() as well. 4.8 Select columns by start of name You want to return evey column in your data that begins with a specific string. Solution table1 %&gt;% select(starts_with(&quot;c&quot;)) ## # A tibble: 6 x 2 ## country cases ## &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 745 ## 2 Afghanistan 2666 ## 3 Brazil 37737 ## 4 Brazil 80488 ## 5 China 212258 ## 6 China 213766 4.9 Select columns by end of name You want to return evey column in your data that ends with a specific string. Solution table1 %&gt;% select(ends_with(&quot;tion&quot;)) ## # A tibble: 6 x 1 ## population ## &lt;int&gt; ## 1 19987071 ## 2 20595360 ## 3 172006362 ## 4 174504898 ## 5 1272915272 ## 6 1280428583 4.10 Select columns by string in name You want to return evey column in your data whose name contains a specific string or regular expression. Solution table1 %&gt;% select(matches(&quot;o.*u&quot;)) ## # A tibble: 6 x 2 ## country population ## &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 19987071 ## 2 Afghanistan 20595360 ## 3 Brazil 172006362 ## 4 Brazil 174504898 ## 5 China 1272915272 ## 6 China 1280428583 Discussion o.*u is a regular expression that matches an o followed by a u with any number of characters in between. country and population are returned because the names country and population each contain an o followed (at any distance) by a u. 4.11 Reorder columns You want to return all of the columns in the original data frame in a new order. Solution table1 %&gt;% select(country, year, population, cases) ## # A tibble: 6 x 4 ## country year population cases ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 19987071 745 ## 2 Afghanistan 2000 20595360 2666 ## 3 Brazil 1999 172006362 37737 ## 4 Brazil 2000 174504898 80488 ## 5 China 1999 1272915272 212258 ## 6 China 2000 1280428583 213766 Discussion Use select() to select all of the columns in the new order. 4.12 Reorder columns without naming all columns You want to reorder some of the columns in the original data frame, but you don’t care about the order for other columns, and you may have too many columns to name them each individually. Solution table1 %&gt;% select(country, year, everything()) ## # A tibble: 6 x 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 Discussion Use everything() within select() to select all of the columns in the order they are named: all columns are kept, and no columns are duplicated. Using everything() preserves the original ordering of the original (unnamed) columns. 4.13 Rename columns You want to rename one or more columns in your data frame, retaining the rest. Solution table1 %&gt;% rename(state = country, date = year) ## # A tibble: 6 x 4 ## state date cases population ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 Discussion For each column to be renamed, type a new name for the column and set it equal to the old name for the column. 4.14 Return the contents of a column as a vector You want to return the contents of a single column as a vector, not as a data frame with one column. Solution table1 %&gt;% pull(cases) ## [1] 745 2666 37737 80488 212258 213766 Discussion pull() comes in the dplyr package. You can also pull a column by integer position: table1 %&gt;% pull(3) ## [1] 745 2666 37737 80488 212258 213766 4.15 Summarise data You want to compute summary statistics for your data set. Solution table1 %&gt;% summarise(total_cases = sum(cases), max_rate = max(cases/population)) ## # A tibble: 1 x 2 ## total_cases max_rate ## &lt;int&gt; &lt;dbl&gt; ## 1 547660 0.000461 Discussion When used by itself, summarise() returns a new 1 x n tibble. Each argument name passed to summarise() will become a column name in the tibble. Each column will contain the result of the R expression passed to the argument/column name. summarise() is intended to be used with summary functions, which are functions that take a vector of values as input and return a single value as output (e.g sum(), max(), mean()). summarize() is an alias for summarise(). 4.16 Summarise data by groups You want to compute and then compare summary statistics for different groups of data in your data set. Solution table1 %&gt;% group_by(country) %&gt;% summarise(total_cases = sum(cases), max_rate = max(cases/population)) ## # A tibble: 3 x 3 ## country total_cases max_rate ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Afghanistan 3411 0.000129 ## 2 Brazil 118225 0.000461 ## 3 China 426024 0.000167 Discussion group_by() converts your data set into a grouped tibble, which is a tibble subclass that indicates in its attributes which rows belong to which group. Where appropriate, tidyverse functions recognize grouped tibbles. The functions: treat each group as a distinct data set execute their code content separately on each group combine the results in a new data frame that contains a column of group labels (as above). Pass group_by() a column to group by the values of that column (rows that contain the same value will be placed in the same group). Pass group_by() two or more column names to group by the distinct combinations of values in those columns. As a rule, tidyverse functions will return a result that contains the same grouping criteria as the original grouped tibble. summarise() is an exception: summarise() removes the last column name from the grouping criteria of its result. Because of this, you can call summarise() repeatedly to view progressively higher level summaries: table1 %&gt;% group_by(country, year) %&gt;% summarise(total_cases = sum(cases)) ## # A tibble: 6 x 3 ## # Groups: country [?] ## country year total_cases ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 ## 2 Afghanistan 2000 2666 ## 3 Brazil 1999 37737 ## 4 Brazil 2000 80488 ## 5 China 1999 212258 ## 6 China 2000 213766 table1 %&gt;% group_by(country, year) %&gt;% summarise(total_cases = sum(cases)) %&gt;% summarise(total_cases = sum(total_cases)) ## # A tibble: 3 x 2 ## country total_cases ## &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 3411 ## 2 Brazil 118225 ## 3 China 426024 table1 %&gt;% group_by(country, year) %&gt;% summarise(total_cases = sum(cases)) %&gt;% summarise(total_cases = sum(total_cases)) %&gt;% summarise(total_cases = sum(total_cases)) ## # A tibble: 1 x 1 ## total_cases ## &lt;int&gt; ## 1 547660 4.17 Mutate data (Add new variables) You want to compute one or more new variables and add them to your table as columns. Solution table1 %&gt;% mutate(rate = cases/population, percent = rate * 100) ## # A tibble: 6 x 6 ## country year cases population rate percent ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan 1999 745 19987071 0.0000373 0.00373 ## 2 Afghanistan 2000 2666 20595360 0.000129 0.0129 ## 3 Brazil 1999 37737 172006362 0.000219 0.0219 ## 4 Brazil 2000 80488 174504898 0.000461 0.0461 ## 5 China 1999 212258 1272915272 0.000167 0.0167 ## 6 China 2000 213766 1280428583 0.000167 0.0167 Discussion mutate() returns a copy of your table that contains additional columns. Each argument name passed to mutate() will become the name of a new column. Each new column will contain the result of the R expression passed to the argument/column name. mutate() will build the columns in the order that you define them. As a result, you may use a column in the column definitions that follow it. mutate() is intended to be used with vectorized functions, which are functions that take a vector of values as input and return a new vector of values as output (e.g abs(), round(), and all of R’s math operations). Use transmute() to return only the new columns that mutate() would create. table1 %&gt;% transmute(rate = cases/population, percent = rate * 100) ## # A tibble: 6 x 2 ## rate percent ## &lt;dbl&gt; &lt;dbl&gt; ## 1 0.0000373 0.00373 ## 2 0.000129 0.0129 ## 3 0.000219 0.0219 ## 4 0.000461 0.0461 ## 5 0.000167 0.0167 ## 6 0.000167 0.0167 "]
]

[
["index.html", "The Tidyverse Cookbook Welcome Legal disclaimer", " The Tidyverse Cookbook Edited by Garrett Grolemund 2019-02-13 Welcome This book collects code recipes for doing data science with R’s tidyverse. Each recipe solves a single common task, with a minimum of discussion. Everything in this book is licensed under the permissive Creative Commons 4.0 International License. We encourage you to reuse and adapt the recipes. Legal disclaimer I believe that each recipe in this book works as advertised, but be aware that the recipes come with the same warranty as R: ABSOLUTELY NO WARRANTY. The online version of this book is licensed under the Creative Commons 4.0 International License. "],
["how-to-use-this-book.html", "How to use this book 0.1 How to get help 0.2 What is the tidyverse?", " How to use this book The recipes in this book are organized according to the model of data science presented in R for Data Science. When you do data science, you find yourself repeating the same sequence of steps: I’ve grouped the recipes by task with the exception of Transform, which is split into chapters based on the type of data or structure to transform. To drill down to a recipe, click on one of the task names in the sidebar. If you are new to R, begin with Program, which will show you how to install the tidyverse. To save space, each recipe assumes that you have already run library(&quot;tidyverse&quot;). If additional library() calls are required, they will appear in the recipe. 0.1 How to get help R comes with a built in reference manual, which is fondly (but sometimes inaccurately) called R’s help pages. You can use R’s help pages to glean details that I do not cover here. To access the help page for an R function, type a ? at the command line of your R console, followed by the function name, and then hit enter to run the result, e.g. ?mutate If a function comes in an R package, you will need to load the package with library() before you can access the function’s help page. Alternatively, you can access the help page by typing a ? followed by the package name, followed by two colons, followed by the function name, e.g. ?dplyr::mutate 0.2 What is the tidyverse? Each of the recipes in this book relies on R’s tidyverse, which is a collection of R packages designed for data science. Tidyverse packages share a common design philosophy, so when you learn how to use one tidyverse package, you learn a lot about how to use the others. Tidyverse packages are also: optimised to run fast, relying on C++ under the hood maintained by a paid staff of talented developers unusually well documented, see tidyverse.org and R for Data Science as examples. Install the complete set of tidyverse packages with: install.packages(&quot;tidyverse&quot;) Each tidyverse package is a collection of functions, documentation, and ideas. You do not need to know which ideas are in the tidyverse to use tidyverse functions, just as you do not need to know which ingredients are in a cake mix to make a cake. However, understanding the tidyverse will help you see the best practices embedded in each recipe. This will make it easier for you to adapt the recipes to your own work. 0.2.1 Tidy data Each package in the tidyverse is designed to use and return tidy data whenever appropriate. Tidy data is tabular data organized so that: Each column contains a single variable Each row contains a single observation In practice, tidy data in R appears as data frames or tibbles. A tibble is an enhanced version of a data frame that is easier to view at the command line. R treats tibbles like data frames in almost every other respect, because tibbles are a subclass of data frame. Tidy tibbles act as a common data structure that tidyverse functions use to talk to each other. Tidy data has other advantages as well. Tidy data aligns with R’s native data structure, the data frame; and tidy data is easy to use with R’s fast, built in vectorized operations. You can think of tidy data as the data format optimized for R. 0.2.2 Tidy tools Each package in the tidyverse also provides tidy tools. Tidy tools are R functions that: Accept and return the same type of data structure (as input and output) Focus on one task per function Can be combined with other functions to perform multi-step operations (using the pipe operator, %&gt;%) Tidy tools are easy to understand and easy to use. They encourage you to organize your work into a sequence of steps that can be considered and checked one at a time. If tidy data is the data format optimized for R, tidy tools are the function format optimized for you. If you’d like a deeper understanding of the tidyverse, I encourage you to read R for Data Science, or to work through the free primers on RStudio Cloud. "],
["program.html", "1 Program What you should know before you begin 1.1 Install a tidyverse package 1.2 Install all of the tidyverse packages 1.3 Load a tidyverse package 1.4 Load the core set of tidyverse packages 1.5 Update a tidyverse package 1.6 Update all of the tidyverse packages 1.7 List all of the tidyverse packages 1.8 Combine functions into a pipe 1.9 Pipe a result to a specific argument", " 1 Program This chapter includes the following recipes. To manipulate vectors with purrr, see Transform Lists and Vectors. Install a tidyverse package Install all of the tidyverse packages Load a tidyverse package Load the core set of tidyverse packages Update a tidyverse package Update all of the tidyverse packages List all of the tidyverse packages Combine functions into a pipe Pipe a result to a specific argument What you should know before you begin The tidyverse is a collection of R packages that are designed to work well together. There are about 25 packages in the tidyverse. An R package is a bundle of functions, documentation, and data sets. R has over 13,000 packages. These are not installed with R, but are archived online for when you need them. To use an R package, you must: Install the package on your local machine with install.packages(). You only need to do this once per machine. Load the package into your R session with library(). You need to do this each time you start a new R session (if you wish to use the package in that session). You cannot use the contents of a package until you load the package in your current R session. You should update your packages from time to time to receive the latest improvements from package authors. Tidyverse functions are designed to be used with the %&gt;% operator. %&gt;% links R functions together to create a “pipe” of functions that are run in sequence: %&gt;% passes the output of one function to the input of the next. %&gt;% comes with the dplyr package, which imports it from the magrittr package. 1.1 Install a tidyverse package You’d like to install a package that is in the tidyverse. Solution install.packages(&quot;dplyr&quot;) Discussion Tidyverse packages can be installed in the normal way with install.packages(). See ?install.packages for installation details. By default, install.packages() will download packages from https://cran.r-project.org, or one of its mirrors—so be sure you are connected to the internet when you run it. 1.2 Install all of the tidyverse packages You’d like to install all of the packages in the tidyverse with a single command. Solution install.packages(&quot;tidyverse&quot;) Discussion The tidyverse package provides a shortcut for downloading all of the packages in the tidyverse. tidyverse purposefully lists every package in the tidyverse as one of its dependencies. This causes R to install all of the packages in the tidyverse when R installs tidyverse. install.packages(&quot;tidyverse&quot;) will install the following packages: ## [1] &quot;broom&quot; &quot;cli&quot; &quot;crayon&quot; &quot;dplyr&quot; &quot;dbplyr&quot; ## [6] &quot;forcats&quot; &quot;ggplot2&quot; &quot;haven&quot; &quot;hms&quot; &quot;httr&quot; ## [11] &quot;jsonlite&quot; &quot;lubridate&quot; &quot;magrittr&quot; &quot;modelr&quot; &quot;purrr&quot; ## [16] &quot;readr&quot; &quot;readxl\\n(&gt;=&quot; &quot;reprex&quot; &quot;rlang&quot; &quot;rstudioapi&quot; ## [21] &quot;rvest&quot; &quot;stringr&quot; &quot;tibble&quot; &quot;tidyr&quot; &quot;xml2&quot; ## [26] &quot;tidyverse&quot; 1.3 Load a tidyverse package You want to load a package that is in the tidyverse, so that you can use its contents. You’ve already installed the package on your computer. Solution library(&quot;dplyr&quot;) Discussion You can load individual tidyverse packages with library(). The package will stay loaded until you end your R session or run detach() on the package. If you begin a new R session, you will need to reload the package in the new session with library(). library() cannot load packages that have not been installed on your machine. You must place quotation marks around a package name when you use install.packages(), but the same is not true for library(). The commands below will both load the dplyr package if it is installed on your computer. library(dplyr) library(&quot;dplyr&quot;) 1.4 Load the core set of tidyverse packages You would like to load the most used packages in the tidyverse with a single command. You’ve already installed these packages on your computer. Solution library(&quot;tidyverse&quot;) Discussion When you load the tidyverse package, R will also load the following packages: ggplot2 dplyr tidyr readr purrr tibble stringr forcats These eight packages are considered the “core” of the tidyverse because: They are the most used tidyverse packages. They are often used together as a set (when you use one of the packages, you tend to also use the others). You can still load each of these packages individually with library(). Notice that library(&quot;tidyverse&quot;) does not load every package installed by install.packages(&quot;tidyverse&quot;). You must use library() to individually load the “non-core” tidyverse packages. 1.5 Update a tidyverse package You want to check that you have the latest version of a package that is in the tidyverse. Solution update.packages(&quot;dplyr&quot;) Discussion update.packages() compares the version number of your local copy of a package to the version number of the newest version available on CRAN. If your local copy is older than the newest version, update.packages() will download and install the newest version from CRAN. Otherwise, update.packages() will do nothing. Be sure that you are connected to the internet when you run update.packages(). 1.6 Update all of the tidyverse packages You want to check that you have the latest version of every package that is in the tidyverse. Solution tidyverse_update() Discussion tidyverse_update() checks whether or not each of your tidyverse packages is up-to-date. If every package is up-to-date, tidyverse_update() will return the message: All tidyverse packages up-to-date. Otherwise, tidyverse_update() will return a piece of code that you can copy and run to selectively update only those packages that are out-of-date. 1.7 List all of the tidyverse packages You want to generate a vector that contains the names of every package in the tidyverse. Solution tidyverse_packages() ## [1] &quot;broom&quot; &quot;cli&quot; &quot;crayon&quot; &quot;dplyr&quot; &quot;dbplyr&quot; ## [6] &quot;forcats&quot; &quot;ggplot2&quot; &quot;haven&quot; &quot;hms&quot; &quot;httr&quot; ## [11] &quot;jsonlite&quot; &quot;lubridate&quot; &quot;magrittr&quot; &quot;modelr&quot; &quot;purrr&quot; ## [16] &quot;readr&quot; &quot;readxl\\n(&gt;=&quot; &quot;reprex&quot; &quot;rlang&quot; &quot;rstudioapi&quot; ## [21] &quot;rvest&quot; &quot;stringr&quot; &quot;tibble&quot; &quot;tidyr&quot; &quot;xml2&quot; ## [26] &quot;tidyverse&quot; Discussion tidyverse_packages() returns a character vector that contains the names of every package that was in the tidyverse when you installed the tidyverse package. These are the packages that were installed onto your machine along with the tidyverse package. They are also the packages that tidyverse_update() will check. Update the tidyverse package before running tidyverse_packages() to receive the most current list. 1.8 Combine functions into a pipe You want to chain multiple functions together to be run in sequence, with each function operating on the preceding function’s output. Solution starwars %&gt;% group_by(species) %&gt;% summarise(avg_height = mean(height, na.rm = TRUE)) %&gt;% arrange(avg_height) ## # A tibble: 38 x 2 ## species avg_height ## &lt;chr&gt; &lt;dbl&gt; ## 1 Yoda&#39;s species 66 ## 2 Aleena 79 ## 3 Ewok 88 ## 4 Vulptereen 94 ## 5 Dug 112 ## 6 Xexto 122 ## 7 Toydarian 137 ## 8 Droid 140 ## 9 Sullustan 160 ## 10 &lt;NA&gt; 160 ## # … with 28 more rows Discussion The %&gt;% operator (pronounced “pipe operator”) evaluates the code on its left hand side (LHS) and then passes the result to the the code on its right hand side (RHS), which should be a function call. By default %&gt;% will pass the result of the LHS to the first unnamed argument of the function on the RHS. So starwars %&gt;% group_by(species) is the equivalent of group_by(starwars, species), and the above solution is the equivalent of the nested code: arrange( summarise( group_by(starwars, species), avg_height = mean(height, na.rm = TRUE) ), avg_height ) or the equivalent of: x1 &lt;- starwars x2 &lt;- group_by(x1, species) x3 &lt;- summarise(x3, avg_height = mean(height, na.rm = TRUE)) arrange(x3, avg_height) The chunk of functions connected by %&gt;% is called a “pipe.” To read a pipe as a sequence of steps, mentally pronounce %&gt;% as “then.” The %&gt;% operator is loaded with the dplyr package, which imports it from the magrittr package. Tidyverse functions facilitate using %&gt;% by accepting a data frame or tibble as their first argument returning a data frame or tibble as their result %&gt;% is easy to type in the RStudio IDE with the keyboard shortcuts Command + Shift + M (Mac OS) Control + Shift + M (Windows) 1.9 Pipe a result to a specific argument You want to use %&gt;% to pass the result of the left hand side to an argument that is not the first argument of the function on the right hand side. Solution starwars %&gt;% lm(mass ~ height, data = .) ## ## Call: ## lm(formula = mass ~ height, data = .) ## ## Coefficients: ## (Intercept) height ## -13.8103 0.6386 Discussion By default %&gt;% passes the result of the left hand side to the the first unnamed argument of the function on the right hand side. To override this default, use . as a placeholder within the function call on the right hand side. %&gt;% will evaluate . as the result of the left hand side, instead of passing the result to the first unnamed argument. The solution code is the equivalent of lm(mass ~ height, data = starwars) "],
["import.html", "2 Import What you should know before you begin 2.1 Import data quickly with a GUI", " 2 Import This chapter includes the following recipes: Import data quickly with a GUI What you should know before you begin Before you can manipulate data with R, you need to import the data into R’s memory, or build a connection to the data that R can use to access the data remotely. How you import your data will depend on the format of the data. The most common way to store small data sets is as a plain text file. Data may also be stored in a proprietary format associated with a specific piece of software, such as SAS, SPSS, or Microsoft Excel. Data used on the internet is often stored as a JSON or XML file. Large data sets may be stored in a database or a distributed storage system. When you import data into R, R stores the data in your computer’s RAM while you manipulate it. This creates a size limitation: truly big data sets should be stored outside of R in a database or distributed storage system. You can then create a connection to the system that R can use to access the data without bringing the data into your computer’s RAM. 2.1 Import data quickly with a GUI You want to import data quickly, and you do not mind using a semi-reproducible graphical user interface (GUI) to do so. Solution Discussion The RStudio IDE provides an Import Dataset button in the Environment pane, which appears in the top right corner of the IDE by default. You can use this button to import data that is stored in plain text files as well as in Excel, SAS, SPSS, and Stata files. Click the button to launch a window that includes a file browser (below). Use the browser to select the file to import. After you’ve selected a file, RStudio will display a preview of how the file will be imported as a data frame. Below the preview, RStudio provides a GUI interface to the common options for importing the type of file you have selected. As you customize the options, RStudio updates the data preview to display the results. The bottom right-hand corner of the window displays R code that, if run, will reproduce your importation process programatically. You should copy and save this code if you wish to document your work in a reproducible workflow. "],
["tidy.html", "3 Tidy What you should know before you begin 3.1 Create a tibble manually 3.2 Convert a data frame to a tibble 3.3 Convert a tibble to a data frame 3.4 Preview the contents of a tibble 3.5 Inspect every cell of a tibble 3.6 Spread a pair of columns into a field of cells 3.7 Gather a field of cells into a pair of columns 3.8 Separate a column into new columns 3.9 Unite multiple columns into a single column", " 3 Tidy This chapter includes the following recipes: Create a tibble manually Convert a data frame to a tibble Convert a tibble to a data frame Preview the contents of a tibble Inspect every cell of a tibble Spread a pair of columns into a field of cells Gather a field of cells into a pair of columns Separate a column into new columns Unite multiple columns into a single column What you should know before you begin Data tidying refers to reshaping your data into a tidy data frame or tibble. Data tidying is an important first step for your analysis because every tidyverse function will expect your data to be stored as Tidy Data. Tidy data is tabular data organized so that: Each column contains a single variable Each row contains a single observation Tidy data is not an arbitrary requirement of the tidyverse; it is the ideal data format for doing data science with R. Tidy data makes it easy to extract every value of a variable to build a plot or to compute a summary statistic. Tidy data also makes it easy to compute new variables; when your data is tidy, you can rely on R’s rowwise operations to maintain the integrity of your observations. Moreover, R can directly manipulate tidy data with R’s fast, built-in vectorised observations, which lets your code run as fast as possible. The definition of Tidy Data isn’t complete until you define variable and observation, so let’s borrow two definitions from R for Data Science: A variable is a quantity, quality, or property that you can measure. An observation is a set of measurements made under similar conditions (you usually make all of the measurements in an observation at the same time and on the same object). As you work with data, you will be surprised to realize that what is a variable (or observation) will depend less on the data itself and more on what you are trying to do with it. With enough mental flexibility, you can consider anything to be a variable. However, some variables will be more useful than others for any specific task. In general, if you can formulate your task as an equation (math or code that contains an equals sign), the most useful variables will be the names in the equation. 3.1 Create a tibble manually You want to create a tibble from scratch by typing in the contents of the tibble. Solution tribble(~number, ~letter, ~greek, 1, &quot;a&quot;, &quot;alpha&quot;, 2, &quot;b&quot;, &quot;beta&quot;, 3, &quot;c&quot;, &quot;gamma&quot;) ## # A tibble: 3 x 3 ## number letter greek ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 a alpha ## 2 2 b beta ## 3 3 c gamma Discussion tribble() creates a tibble and tricks you into typing out a preview of the result. To use tribble(), list each column name preceded by a ~, then list the values of the tribble in a rowwise fashion. If you take care to align your columns, the transposed syntax of tribble() becomes a preview of the table. You can also create a tibble with tibble(), whose syntax mirrors data.frame(): tibble(number = c(1, 2, 3), letter = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), greek = c(&quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;)) 3.2 Convert a data frame to a tibble You want to convert a data frame to a tibble. Solution as_tibble(iris) ## # A tibble: 150 x 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## 7 4.6 3.4 1.4 0.3 setosa ## 8 5 3.4 1.5 0.2 setosa ## 9 4.4 2.9 1.4 0.2 setosa ## 10 4.9 3.1 1.5 0.1 setosa ## # … with 140 more rows 3.3 Convert a tibble to a data frame You want to convert a tibble to a data frame. Solution as.data.frame(table1) ## country year cases population ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 Discussion Be careful to use as.data.frame() and not as_data_frame(), which is an alias for as_tibble(). 3.4 Preview the contents of a tibble You want to get an idea of what variables and values are stored in a tibble. Solution storms ## # A tibble: 10,010 x 13 ## name year month day hour lat long status category wind pressure ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;ord&gt; &lt;int&gt; &lt;int&gt; ## 1 Amy 1975 6 27 0 27.5 -79 tropi… -1 25 1013 ## 2 Amy 1975 6 27 6 28.5 -79 tropi… -1 25 1013 ## 3 Amy 1975 6 27 12 29.5 -79 tropi… -1 25 1013 ## 4 Amy 1975 6 27 18 30.5 -79 tropi… -1 25 1013 ## 5 Amy 1975 6 28 0 31.5 -78.8 tropi… -1 25 1012 ## 6 Amy 1975 6 28 6 32.4 -78.7 tropi… -1 25 1012 ## 7 Amy 1975 6 28 12 33.3 -78 tropi… -1 25 1011 ## 8 Amy 1975 6 28 18 34 -77 tropi… -1 30 1006 ## 9 Amy 1975 6 29 0 34.4 -75.8 tropi… 0 35 1004 ## 10 Amy 1975 6 29 6 34 -74.8 tropi… 0 40 1002 ## # … with 10,000 more rows, and 2 more variables: ts_diameter &lt;dbl&gt;, ## # hu_diameter &lt;dbl&gt; Discussion When you call a tibble directly, R will display enough information to give you a quick sense of the contents of the tibble. This includes: the dimensions of the tibble the column names and types as many cells of the tibble as will fit comfortably in your console window 3.5 Inspect every cell of a tibble You want to see every value that is stored in a tibble. Solution View(storms) Discussion View() (with a capital V) opens the tibble in R’s data viewer, which will let you scroll to every cell in the tibble. 3.6 Spread a pair of columns into a field of cells You want to pivot, convert long data to wide, or move variable names out of the cells and into the column names. These are different ways of describing the same action. For example, table2 contains type, which is a column that repeats the variable names case and population. To make table2 tidy, you must move case and population values into their own columns. table2 ## # A tibble: 12 x 4 ## country year type count ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 1999 cases 745 ## 2 Afghanistan 1999 population 19987071 ## 3 Afghanistan 2000 cases 2666 ## 4 Afghanistan 2000 population 20595360 ## 5 Brazil 1999 cases 37737 ## 6 Brazil 1999 population 172006362 ## 7 Brazil 2000 cases 80488 ## 8 Brazil 2000 population 174504898 ## 9 China 1999 cases 212258 ## 10 China 1999 population 1272915272 ## 11 China 2000 cases 213766 ## 12 China 2000 population 1280428583 Solution table2 %&gt;% spread(key = type, value = count) ## # A tibble: 6 x 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 Discussion To use spread(), assign the column that contains variable names to key. Assign the column that contains the values that are associated with those names to value. spread() will: Make a copy of the original table Remove the key and value columns from the copy Remove every duplicate row in the data set that remains Insert a new column for each unique variable name in the key column Fill the new columns with the values of the value column in a way that preserves every relationship between values in the original data set Since this is easier to see than explain, you may want to study the diagram and result above. Each new column created by spread() will inherit the data type of the value column. If you would to convert each new column to the most sensible data type given its final contents, add the argument convert = TRUE. 3.7 Gather a field of cells into a pair of columns You want to convert wide data to long, reshape a two-by-two table, or move variable values out of the column names and into the cells. These are different ways of describing the same action. For example, table4a is a two-by-two table with the column names 1999 and 2000. These names are values of a year variable. The field of cells in table4a contains counts of TB cases, which is another variable. To make table4a tidy, you need to move year and case values into their own columns. table4a ## # A tibble: 3 x 3 ## country `1999` `2000` ## * &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 745 2666 ## 2 Brazil 37737 80488 ## 3 China 212258 213766 Solution table4a %&gt;% gather(key = &quot;year&quot;, value = &quot;cases&quot;, 2:3) ## # A tibble: 6 x 3 ## country year cases ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 ## 2 Brazil 1999 37737 ## 3 China 1999 212258 ## 4 Afghanistan 2000 2666 ## 5 Brazil 2000 80488 ## 6 China 2000 213766 Discussion gather() is the inverse of spread(): gather() collapses a field of cells that spans several columns into two new columns: A column of former “keys”, which contains the column names of the former field A column of former “values”, which contains the cell values of the former field To use gather(), pick names for the new key and value columns, and supply them as strings. Then identify the columns to gather into the new key and value columns. gather() will: Create a copy of the original table Remove the identified columns from the copy Add a key column with the supplied name Fill the key column with the column names of the removed columns, repeating rows as necessary so that each combination of row and removed column name appears once Add a value column with the supplied name Fill the value column with the values of the removed columns in a way that preserves every relationship between values and column names in the original data set Since this is easier to see than explain, you may want to study the diagram and result above. Identify columns to gather You can identify the columns to gather (i.e. remove) by: name index (numbers) inverse index (negative numbers that specifiy the columns to retain, all other columns will be removed.) the select() helpers that come in the dplyr package So for example, the following commands will do the same thing as the solution above: table4a %&gt;% gather(key = &quot;year&quot;, value = &quot;cases&quot;, `&quot;1999&quot;, &quot;2000&quot;) table4a %&gt;% gather(key = &quot;year&quot;, value = &quot;cases&quot;, -1) table4a %&gt;% gather(key = &quot;year&quot;, value = &quot;cases&quot;, one_of(c(&quot;1999&quot;, &quot;2000&quot;))) By default, the new key column will contain character strings. If you would like to convert the new key column to the most sensible data type given its final contents, add the argument convert = TRUE. 3.8 Separate a column into new columns You want to split a single column into multiple columns by separating each cell in the column into a row of cells. Each new cell should contain a separate portion of the value in the original cell. For example, table3 combines cases and population values in a single column named rate. To tidy table3, you need to separate rate into two columns: one for the cases variable and one for the population variable. table3 ## # A tibble: 6 x 3 ## country year rate ## * &lt;chr&gt; &lt;int&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745/19987071 ## 2 Afghanistan 2000 2666/20595360 ## 3 Brazil 1999 37737/172006362 ## 4 Brazil 2000 80488/174504898 ## 5 China 1999 212258/1272915272 ## 6 China 2000 213766/1280428583 Solution table3 %&gt;% separate(col = rate, into = c(&quot;cases&quot;, &quot;population&quot;), sep = &quot;/&quot;, convert = TRUE) ## # A tibble: 6 x 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 Discussion To use separate(), pass col the name of the column to split, and pass into a vector of names for the new columns to split col into. You should supply one name for each new column that you expect to appear in the result; a mismatch will imply that something went wrong. separate() will: Create a copy of the original data set Add a new column for each value of into. The values will become the names of the new columns. Split each cell of col into multiple values, based on the locations of a separator character. Place the new values into the new columns in order, one value per column Remove the col column. Add the argument remove = FALSE to retain the col column in the final result. Since this is easier to see than explain, you may want to study the diagram and result above. Each new column created by separate() will inherit the data type of the col column. If you would like to convert each new column to the most sensible data type given its final contents, add the argument convert = TRUE. Control where cells are separated By default, separate() will use non-alpha-numeric characters as a separators. Pass a regular expression to the sep argument to specify a different set of separators. Alternatively, pass an integer vector to the sep argument to split cells into sequences that each have a specific number of characters: sep = 1 will split each cell between the first and second character. sep = c(1, 3) will split each cell between the first and second character and then again between the third and fourth character. sep = -1 will split each cell between the last and second to last character. Separate into multiple rows separate_rows() behaves like separate() except that it places each new value into a new row (instead of into a new column). To use separate_rows(), follow the same syntax as separate(). 3.9 Unite multiple columns into a single column You want to combine several columns into a single column by uniting their values across rows. For example, table5 splits the year variable across two columns: century and year. To make table5 tidy, you need to unite century and year into a single column. table5 ## # A tibble: 6 x 4 ## country century year rate ## * &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 19 99 745/19987071 ## 2 Afghanistan 20 00 2666/20595360 ## 3 Brazil 19 99 37737/172006362 ## 4 Brazil 20 00 80488/174504898 ## 5 China 19 99 212258/1272915272 ## 6 China 20 00 213766/1280428583 Solution table5 %&gt;% unite(col = &quot;year&quot;, century, year, sep = &quot;&quot;) ## # A tibble: 6 x 3 ## country year rate ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745/19987071 ## 2 Afghanistan 2000 2666/20595360 ## 3 Brazil 1999 37737/172006362 ## 4 Brazil 2000 80488/174504898 ## 5 China 1999 212258/1272915272 ## 6 China 2000 213766/1280428583 Discussion To use unite(), give the col argument a character string to use as the name of the new column to create. Then list the columns to combine. Finally, give the sep argument a separator character to use to paste together the values in the cells of each column. unite() will: Create a copy of the original data set Paste together the values of the listed columns in a vectorized (i.e. rowwise) fashion. unite() will place the value of sep between each value during the paste process. Append the results as a new column whose name is the value of col Remove the listed columns. To retain the columns in the result, add the argument remove = FALSE. Since this is easier to see than explain, you may want to study the diagram and result above. If you do not suppy a sep value, unite() will use _ as a separator character. To avoid a separator character, use sep = &quot;&quot;. "],
["transform-tables.html", "4 Transform Tables What you should know before you begin 4.1 Arrange rows by value in ascending order 4.2 Arrange rows by value in descending order 4.3 Filter rows with a logical test 4.4 Select columns by name 4.5 Drop columns by name 4.6 Select a range of columns 4.7 Select columns by integer position 4.8 Select columns by start of name 4.9 Select columns by end of name 4.10 Select columns by string in name 4.11 Reorder columns 4.12 Reorder columns without naming each 4.13 Rename columns 4.14 Return the contents of a column as a vector 4.15 Mutate data (Add new variables) 4.16 Summarise data 4.17 Group data 4.18 Summarise data by groups 4.19 Nest a data frame 4.20 Combine transform recipes 4.21 Join data sets by common column(s) 4.22 Find rows that have a match in another data set 4.23 Find rows that do not have a match in another data set", " 4 Transform Tables This chapter includes the following recipes: Arrange rows by value in ascending order Arrange rows by value in descending order Filter rows with a logical test Select columns by name Drop columns by name Select a range of columns Select columns by integer position Select columns by start of name Select columns by end of name Select columns by string in name Reorder columns Reorder columns without naming each Rename columns Return the contents of a column as a vector Mutate data (Add new variables) Summarise data Group data Summarise data by groups Nest a data frame Combine transform recipes Join data sets by common column(s) Find rows that have a match in another data set Find rows that do not have a match in another data set What you should know before you begin The dplyr package provides the most important tidyverse functions for manipulating tables. These functions share some defaults that make it easy to transform tables: dplyr functions always return a transformed copy of your table. They won’t change your original table unless you tell them to (by saving over the name of the original table). That’s good news, because you should always retain a clean copy of your original data in case something goes wrong. You can refer to columns by name inside of a dplyr function. There’s no need for $ syntax or &quot;&quot;. Every dplyr function requires you to supply a data frame, and it will recognize the columns in that data frame, e.g. summarise(mpg, h = mean(hwy), c = mean(cty)) This only becomes a problem if you’d like to use an object that has the same name as one of the columns in the data frame. In this case, place !! before the object’s name to unquote it, dplyr will skip the columns when looking up the object. e.g. hwy &lt;- 1:10 summarise(mpg, h = mean(!!hwy), c = mean(cty)) Transforming a table sometimes requires more than one recipe. Why? Because tables are made of multiple data structures that work together: The table itself is a data frame or tibble. The columns of the table are vectors. Some columns may be list-columns, which are lists that contain vectors. Each tidyverse function tends to focus on a single type of data structure; it is part of the tidyverse philosophy that each function should do one thing and do it well. So to transform a table, begin with a recipe that transforms the structure of the table. You’ll find those recipes in this chapter. Then complete it with a recipe that transforms the actual data values in your table. The Combine transform recipes recipe will show you how. 4.1 Arrange rows by value in ascending order You want to sort the rows of a data frame in ascending order by the values in one or more columns. Solution mpg %&gt;% arrange(displ) ## # A tibble: 234 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 honda civic 1.6 1999 4 manu… f 28 33 r subc… ## 2 honda civic 1.6 1999 4 auto… f 24 32 r subc… ## 3 honda civic 1.6 1999 4 manu… f 25 32 r subc… ## 4 honda civic 1.6 1999 4 manu… f 23 29 p subc… ## 5 honda civic 1.6 1999 4 auto… f 24 32 r subc… ## 6 audi a4 1.8 1999 4 auto… f 18 29 p comp… ## 7 audi a4 1.8 1999 4 manu… f 21 29 p comp… ## 8 audi a4 q… 1.8 1999 4 manu… 4 18 26 p comp… ## 9 audi a4 q… 1.8 1999 4 auto… 4 16 25 p comp… ## 10 honda civic 1.8 2008 4 manu… f 26 34 r subc… ## # … with 224 more rows Discussion arrange() sorts the rows according to the values of the specified column, with the lowest values appearing near the top of the data frame. If you provide additional column names, arrange() will use the additional columns in order as tiebreakers to sort within rows that share the same value of the first column. mpg %&gt;% arrange(displ, cty) ## # A tibble: 234 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 honda civic 1.6 1999 4 manu… f 23 29 p subc… ## 2 honda civic 1.6 1999 4 auto… f 24 32 r subc… ## 3 honda civic 1.6 1999 4 auto… f 24 32 r subc… ## 4 honda civic 1.6 1999 4 manu… f 25 32 r subc… ## 5 honda civic 1.6 1999 4 manu… f 28 33 r subc… ## 6 audi a4 q… 1.8 1999 4 auto… 4 16 25 p comp… ## 7 audi a4 1.8 1999 4 auto… f 18 29 p comp… ## 8 audi a4 q… 1.8 1999 4 manu… 4 18 26 p comp… ## 9 volkswagen pass… 1.8 1999 4 auto… f 18 29 p mids… ## 10 audi a4 1.8 1999 4 manu… f 21 29 p comp… ## # … with 224 more rows 4.2 Arrange rows by value in descending order You want to sort the rows of a data frame in descending order by the values in one or more columns. Solution mpg %&gt;% arrange(desc(displ)) ## # A tibble: 234 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 chevrolet corv… 7 2008 8 manu… r 15 24 p 2sea… ## 2 chevrolet k150… 6.5 1999 8 auto… 4 14 17 d suv ## 3 chevrolet corv… 6.2 2008 8 manu… r 16 26 p 2sea… ## 4 chevrolet corv… 6.2 2008 8 auto… r 15 25 p 2sea… ## 5 jeep gran… 6.1 2008 8 auto… 4 11 14 p suv ## 6 chevrolet c150… 6 2008 8 auto… r 12 17 r suv ## 7 dodge dura… 5.9 1999 8 auto… 4 11 15 r suv ## 8 dodge ram … 5.9 1999 8 auto… 4 11 15 r pick… ## 9 chevrolet c150… 5.7 1999 8 auto… r 13 17 r suv ## 10 chevrolet corv… 5.7 1999 8 manu… r 16 26 p 2sea… ## # … with 224 more rows Discussion Place desc() around a column name to cause arrange() to sort by descending values of that column. You can use desc() for tie-breaker columns as well (compare line nine below to the table above). mpg %&gt;% arrange(desc(displ), desc(cty)) ## # A tibble: 234 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 chevrolet corv… 7 2008 8 manu… r 15 24 p 2sea… ## 2 chevrolet k150… 6.5 1999 8 auto… 4 14 17 d suv ## 3 chevrolet corv… 6.2 2008 8 manu… r 16 26 p 2sea… ## 4 chevrolet corv… 6.2 2008 8 auto… r 15 25 p 2sea… ## 5 jeep gran… 6.1 2008 8 auto… 4 11 14 p suv ## 6 chevrolet c150… 6 2008 8 auto… r 12 17 r suv ## 7 dodge dura… 5.9 1999 8 auto… 4 11 15 r suv ## 8 dodge ram … 5.9 1999 8 auto… 4 11 15 r pick… ## 9 chevrolet corv… 5.7 1999 8 manu… r 16 26 p 2sea… ## 10 chevrolet corv… 5.7 1999 8 auto… r 15 23 p 2sea… ## # … with 224 more rows 4.3 Filter rows with a logical test You want to filter your table to just the rows that meet a specific condition. Solution mpg %&gt;% filter(model == &quot;jetta&quot;) ## # A tibble: 9 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 volkswagen jetta 1.9 1999 4 manua… f 33 44 d comp… ## 2 volkswagen jetta 2 1999 4 manua… f 21 29 r comp… ## 3 volkswagen jetta 2 1999 4 auto(… f 19 26 r comp… ## 4 volkswagen jetta 2 2008 4 auto(… f 22 29 p comp… ## 5 volkswagen jetta 2 2008 4 manua… f 21 29 p comp… ## 6 volkswagen jetta 2.5 2008 5 auto(… f 21 29 r comp… ## 7 volkswagen jetta 2.5 2008 5 manua… f 21 29 r comp… ## 8 volkswagen jetta 2.8 1999 6 auto(… f 16 23 r comp… ## 9 volkswagen jetta 2.8 1999 6 manua… f 17 24 r comp… Discussion filter() takes a logical test and returns the rows for which the logical test returns TRUE. filter() will match column names that appear within the logical test to columns in your data frame. If you provide multiple logical tests, filter() will combine them with an AND operator (&amp;): mpg %&gt;% filter(model == &quot;jetta&quot;, year == 1999) Use R’s boolean operators, like |and !, to create other combinations of logical tests to pass to filter. See the help pages for ?Comparison and ?Logic to learn more about writing logical tests in R. 4.4 Select columns by name You want to return a “subset” of columns from your data frame by listing the name of each column to return. Solution table1 %&gt;% select(country, year, cases) ## # A tibble: 6 x 3 ## country year cases ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 ## 2 Afghanistan 2000 2666 ## 3 Brazil 1999 37737 ## 4 Brazil 2000 80488 ## 5 China 1999 212258 ## 6 China 2000 213766 Discussion select() returns a new data frame that includes each column passed to select(). Repeat a name to include the column twice. 4.5 Drop columns by name You want to return a “subset” of columns from your data frame by listing the name of each column to drop. Solution table1 %&gt;% select(-c(population, year)) ## # A tibble: 6 x 2 ## country cases ## &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 745 ## 2 Afghanistan 2666 ## 3 Brazil 37737 ## 4 Brazil 80488 ## 5 China 212258 ## 6 China 213766 Discussion If you use a - before a column name, select() will return every column in the data frame except that column. To drop more than one column at a time, group the columns into a vector preceded by -. 4.6 Select a range of columns You want to return two columns from a data frame as well as every column that appears between them. Solution table1 %&gt;% select(country:cases) ## # A tibble: 6 x 3 ## country year cases ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 ## 2 Afghanistan 2000 2666 ## 3 Brazil 1999 37737 ## 4 Brazil 2000 80488 ## 5 China 1999 212258 ## 6 China 2000 213766 Discussion If you combine two column names with a :, select() will return both columns and every column that appears between them in the data frame. 4.7 Select columns by integer position You want to return a “subset” of columns from your data frame by listing the position of each column to return. Solution table1 %&gt;% select(1, 2, 4) ## # A tibble: 6 x 3 ## country year population ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 19987071 ## 2 Afghanistan 2000 20595360 ## 3 Brazil 1999 172006362 ## 4 Brazil 2000 174504898 ## 5 China 1999 1272915272 ## 6 China 2000 1280428583 Discussion select() interprets the whole number n as the _n_th column in the data set. You can combine numbers with - and : inside of select() as well. 4.8 Select columns by start of name You want to return evey column in your data that begins with a specific string. Solution table1 %&gt;% select(starts_with(&quot;c&quot;)) ## # A tibble: 6 x 2 ## country cases ## &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 745 ## 2 Afghanistan 2666 ## 3 Brazil 37737 ## 4 Brazil 80488 ## 5 China 212258 ## 6 China 213766 4.9 Select columns by end of name You want to return evey column in your data that ends with a specific string. Solution table1 %&gt;% select(ends_with(&quot;tion&quot;)) ## # A tibble: 6 x 1 ## population ## &lt;int&gt; ## 1 19987071 ## 2 20595360 ## 3 172006362 ## 4 174504898 ## 5 1272915272 ## 6 1280428583 4.10 Select columns by string in name You want to return evey column in your data whose name contains a specific string or regular expression. Solution table1 %&gt;% select(matches(&quot;o.*u&quot;)) ## # A tibble: 6 x 2 ## country population ## &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 19987071 ## 2 Afghanistan 20595360 ## 3 Brazil 172006362 ## 4 Brazil 174504898 ## 5 China 1272915272 ## 6 China 1280428583 Discussion o.*u is a regular expression that matches an o followed by a u with any number of characters in between. country and population are returned because the names country and population each contain an o followed (at any distance) by a u. See the help page for ?regex to learn more about regular expressions in R. 4.11 Reorder columns You want to return all of the columns in the original data frame in a new order. Solution table1 %&gt;% select(country, year, population, cases) ## # A tibble: 6 x 4 ## country year population cases ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 19987071 745 ## 2 Afghanistan 2000 20595360 2666 ## 3 Brazil 1999 172006362 37737 ## 4 Brazil 2000 174504898 80488 ## 5 China 1999 1272915272 212258 ## 6 China 2000 1280428583 213766 Discussion Use select() to select all of the columns. List the column names in the new order. 4.12 Reorder columns without naming each You want to reorder some of the columns in the original data frame, but you don’t care about the order for other columns, and you may have too many columns to name them each individually. Solution table1 %&gt;% select(country, year, everything()) ## # A tibble: 6 x 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 Discussion Use everything() within select() to select all of the columns in the order they are named: all columns are kept, and no columns are duplicated. Using everything() preserves the original ordering of the original (unnamed) columns. 4.13 Rename columns You want to rename one or more columns in your data frame, retaining the rest. Solution table1 %&gt;% rename(state = country, date = year) ## # A tibble: 6 x 4 ## state date cases population ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 Discussion For each column to be renamed, type a new name for the column and set it equal to the old name for the column. 4.14 Return the contents of a column as a vector You want to return the contents of a single column as a vector, not as a data frame with one column. Solution table1 %&gt;% pull(cases) ## [1] 745 2666 37737 80488 212258 213766 Discussion pull() comes in the dplyr package. It does the equivalent of pluck() in the purrr package; however, pull() is designed to work specifically with data frames. pluck() is designed to work with all types of lists. You can also pull a column by integer position: table1 %&gt;% pull(3) ## [1] 745 2666 37737 80488 212258 213766 4.15 Mutate data (Add new variables) You want to compute one or more new variables and add them to your table as columns. Solution table1 %&gt;% mutate(rate = cases/population, percent = rate * 100) ## # A tibble: 6 x 6 ## country year cases population rate percent ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan 1999 745 19987071 0.0000373 0.00373 ## 2 Afghanistan 2000 2666 20595360 0.000129 0.0129 ## 3 Brazil 1999 37737 172006362 0.000219 0.0219 ## 4 Brazil 2000 80488 174504898 0.000461 0.0461 ## 5 China 1999 212258 1272915272 0.000167 0.0167 ## 6 China 2000 213766 1280428583 0.000167 0.0167 Discussion To use mutate(), pass it a series of names followed by R expressions. mutate() will return a copy of your table that contains one column for each name that you pass to mutate(). The name of the column will be the name that you passed to mutate(); the contents of the column will be the result of the R expression that you assigned to the name. The R expression should always return a vector of the same length as the other columns in the data frame,1 because mutate() will add the vector as a new column. In other words, mutate() is intended to be used with vectorized functions, which are functions that take a vector of values as input and return a new vector of values as output (e.g abs(), round(), and all of R’s math operations). mutate() will build the columns in the order that you define them. As a result, you may use a new column in the column definitions that follow it. Dropping the original data Use transmute() to return only the new columns that mutate() would create. table1 %&gt;% transmute(rate = cases/population, percent = rate * 100) ## # A tibble: 6 x 2 ## rate percent ## &lt;dbl&gt; &lt;dbl&gt; ## 1 0.0000373 0.00373 ## 2 0.000129 0.0129 ## 3 0.000219 0.0219 ## 4 0.000461 0.0461 ## 5 0.000167 0.0167 ## 6 0.000167 0.0167 4.16 Summarise data You want to compute summary statistics for the data in your data frame. Solution table1 %&gt;% summarise(total_cases = sum(cases), max_rate = max(cases/population)) ## # A tibble: 1 x 2 ## total_cases max_rate ## &lt;int&gt; &lt;dbl&gt; ## 1 547660 0.000461 Discussion To use summarise(), pass it a series of names followed by R expressions. summarise() will return a new tibble that contains one column for each name that you pass to summarise(). The name of the column will be the name that you passed to summarise(); the contents of the column will be the result of the R expression that you assigned to the name. The R expression should always return a single value because summarise() will always return a 1 x n tibble.2 In other words, summarise() is intended to be used with summary functions, which are functions that take a vector of values as input and return a single value as output (e.g sum(), max(), mean()). In normal use, summarise() will pass each function a column (i.e. vector) of values and expect a single value in return. summarize() is an alias for summarise(). 4.17 Group data You want to assign the rows of your data to subgroups based on their shared values or their shared combinations of values. You want to do this as the first step in a multi-step analysis, because grouping data doesn’t do anything noticeable until you pass the grouped data to a tidyverse function. Solution table1 %&gt;% group_by(country) ## # A tibble: 6 x 4 ## # Groups: country [3] ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 Discussion group_by() converts your data into a grouped tibble, which is a tibble subclass that indicates in its attributes3 which rows belong to which group. To group rows by the values of a single column, pass group_by() a single column name. To group rows by the unique combination of values across multiple columns, pass group_by() the names of two or more columns. Group-wise operations Where appropriate, tidyverse functions recognize grouped tibbles. Tidyverse functions: treat each group as a distinct data set execute their code separately on each group combine the results into a new data frame that contains the same grouping characteristics. summarise() is a slight exception, see below. 4.18 Summarise data by groups You want to compute summary statistics for different subgroups of data in your grouped data frame. Solution table1 %&gt;% group_by(country) %&gt;% summarise(total_cases = sum(cases), max_rate = max(cases/population)) ## # A tibble: 3 x 3 ## country total_cases max_rate ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Afghanistan 3411 0.000129 ## 2 Brazil 118225 0.000461 ## 3 China 426024 0.000167 Discussion Group-wise summaries are the most common use of grouped data. When you apply summarise() to grouped data, summarise() will: treat each group as a distinct data set compute separate statistics for each group combine the results into a new tibble Since this is easier to see than explain, you may want to study the diagram and result above. summarise() gives grouped data special treatment in two ways: summarise() will retain the column(s) that were used to group the data in its result. This makes the output of grouped summaries interpretable. summarise() will shorten the grouping criteria of its result by one column name (the last column name). Compare this to other tidyverse functions which give their result the same grouping criteria as their input. For example, if the input of summarise() is grouped by country and year, the output of summarise() will only be grouped by country. Because of this, you can call summarise() repeatedly to view progressively higher level summaries: table1 %&gt;% group_by(country, year) %&gt;% summarise(total_cases = sum(cases)) ## # A tibble: 6 x 3 ## # Groups: country [?] ## country year total_cases ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 ## 2 Afghanistan 2000 2666 ## 3 Brazil 1999 37737 ## 4 Brazil 2000 80488 ## 5 China 1999 212258 ## 6 China 2000 213766 table1 %&gt;% group_by(country, year) %&gt;% summarise(total_cases = sum(cases)) %&gt;% summarise(total_cases = sum(total_cases)) ## # A tibble: 3 x 2 ## country total_cases ## &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 3411 ## 2 Brazil 118225 ## 3 China 426024 table1 %&gt;% group_by(country, year) %&gt;% summarise(total_cases = sum(cases)) %&gt;% summarise(total_cases = sum(total_cases)) %&gt;% summarise(total_cases = sum(total_cases)) ## # A tibble: 1 x 1 ## total_cases ## &lt;int&gt; ## 1 547660 4.19 Nest a data frame You want to move portions of your data frame into their own tables, and then store those tables in cells in your original data frame. This lets you manipulate the collection of tables with filter(), select(), arrange(), and so on, as you would normally manipulate a collection of values. Solution iris %&gt;% group_by(Species) %&gt;% nest(.key = &quot;Measurements&quot;) ## # A tibble: 3 x 2 ## Species Measurements ## &lt;fct&gt; &lt;list&gt; ## 1 setosa &lt;tibble [50 × 4]&gt; ## 2 versicolor &lt;tibble [50 × 4]&gt; ## 3 virginica &lt;tibble [50 × 4]&gt; Discussion nest() comes in the tidyr package. You can use it to nest portions of your data frame in two ways: Pass nest() a grouped data frame made with dplyr::group_by() (as above). nest() will create a separate table for each group. The table will contain every row in the group and every column that is not part of the grouping criteria. Pass nest() an ungrouped data frame and then specify which columns to nest. nest() will perform an implicit grouping on the combination of values that appear across the remaining columns, and then create a separate table for each implied grouping. You can specify columns with the same syntax and helpers that you would use with dplyr’s select() function. So, for example, the two calls below will produce the same result as the solution above. iris %&gt;% nest(Sepal.Width, Sepal.Length, Petal.Width, Petal.Length, .key = &quot;Measurements&quot;) %&gt;% as_tibble() iris %&gt;% nest(-Species, .key = &quot;Measurements&quot;) %&gt;% as_tibble() nest() preserves class, which means that nest() will return a data frame if its input is a data frame and a tibble if its input is a tibble. In each case, nest() will add the sub-tables to the result as a list-column. Since, list-columns are much easier to view in a tibble than a data frame, I recommend that you convert the result of nest() to a tibble when necessary. Use the .key argument to provide a name for the new list-column. 4.20 Combine transform recipes You want to transform the structure of a table, and you want to use the data within the table to do it. This is the sort of thing you do everytime you call summarise() or mutate(). Solution See the discussion. Discussion When you transform a data frame, you often work with several functions: A function that transforms the table itself, adding columns to its structure, or building a whole new table to hold results. A function that transforms the values held in the table. Since values are always held in vectors (here column vectors), this function transforms a vector to create a new vector that can then be added to the empty column or table created by function 1. A function that mediates between 1 and 2 if the values are embedded in a list-column, which is a list. The most concise way to learn how to combine these functions is to learn about the functions in isolation, and to then have the functions call each other as necessary. An example smiths contains measurements that describe two fictional people: John and Mary Smith. smiths ## # A tibble: 2 x 5 ## subject time age weight height ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 John Smith 1 33 90 1.87 ## 2 Mary Smith 1 NA NA 1.54 To round the height value for each person, you would need two functions: round() which can round the values of the data vector stored in smiths$height. round(smiths$height) ## [1] 2 2 mutate() which can add the results to a copy of the smiths table. smiths %&gt;% mutate(height_int = round(height)) ## # A tibble: 2 x 6 ## subject time age weight height height_int ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 John Smith 1 33 90 1.87 2 ## 2 Mary Smith 1 NA NA 1.54 2 round() works with data vectors. mutate() works with tables. Together they create the table you want. An example that uses list columns sepals is a tibble that I made for this example.4 It contains sepal length measurements for three species of flowers. The measurements are stored in a list-column named lengths. sepals ## # A tibble: 3 x 2 ## Species lengths ## &lt;fct&gt; &lt;list&gt; ## 1 setosa &lt;dbl [50]&gt; ## 2 versicolor &lt;dbl [50]&gt; ## 3 virginica &lt;dbl [50]&gt; Each cell in lengths contains a data vector of 50 sepal lengths. # For example, the first cell of lengths sepals[[1, 2]] ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 ## [18] 5.1 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 ## [35] 4.9 5.0 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 To add the average sepal length for each species to the table, you would need three functions: mean() which can compute the average of a data vector in lengths mean(sepals[[1, 2]]) ## [1] 5.006 map_dbl() which can apply mean() to each cell of lengths, which is a list-column. map_dbl(sepals$lengths, mean) ## [1] 5.006 5.936 6.588 mutate() which can add the results to a copy of the sepals table. sepals %&gt;% mutate(avg_length = map_dbl(lengths, mean)) ## # A tibble: 3 x 3 ## Species lengths avg_length ## &lt;fct&gt; &lt;list&gt; &lt;dbl&gt; ## 1 setosa &lt;dbl [50]&gt; 5.01 ## 2 versicolor &lt;dbl [50]&gt; 5.94 ## 3 virginica &lt;dbl [50]&gt; 6.59 mean() works with data vectors. map_dbl() works with list-columns. mutate() works with tables. Together they create the table you want. 4.21 Join data sets by common column(s) You want to combine two data frames into a single data frame, such that observations in the first data frame are matched to the corresponding observations in the second data frame, even if those observations do not appear in the same order. Your data is structured in such a way that you can match observations by the values of one or more ID columns that appear in both data frames. For example, you would like to combine band_members and band_instruments into a single data frame based on the values of the name column. The new data frame will correctly list who plays what. band_members ## # A tibble: 3 x 2 ## name band ## &lt;chr&gt; &lt;chr&gt; ## 1 Mick Stones ## 2 John Beatles ## 3 Paul Beatles band_instruments ## # A tibble: 3 x 2 ## name plays ## &lt;chr&gt; &lt;chr&gt; ## 1 John guitar ## 2 Paul bass ## 3 Keith guitar Solution band_members %&gt;% left_join(band_instruments, by = &quot;name&quot;) ## # A tibble: 3 x 3 ## name band plays ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Mick Stones &lt;NA&gt; ## 2 John Beatles guitar ## 3 Paul Beatles bass Discussion There are four ways to join content from one data frame to another. Each uses a different function name, but the same arguments and syntax. Of these, left_join() is the most common. left_join() drops any row in the second data set does not match a row in the first data set. (It retains every row in the first data set, which appears on the left when you type the function call, hence the name). right_join() drops any row in the first data set does not match a row in the first data set. band_members %&gt;% right_join(band_instruments, by = &quot;name&quot;) ## # A tibble: 3 x 3 ## name band plays ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 John Beatles guitar ## 2 Paul Beatles bass ## 3 Keith &lt;NA&gt; guitar inner_join() drops any row in either data set that does not have a match in both data sets, i.e. inner_join() does not retain any incomplete rows in the final result. band_members %&gt;% inner_join(band_instruments, by = &quot;name&quot;) ## # A tibble: 2 x 3 ## name band plays ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 John Beatles guitar ## 2 Paul Beatles bass full_join() retains every row from both data sets; it is the only join guaranteed to retain all of the original data. band_members %&gt;% full_join(band_instruments, by = &quot;name&quot;) ## # A tibble: 4 x 3 ## name band plays ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Mick Stones &lt;NA&gt; ## 2 John Beatles guitar ## 3 Paul Beatles bass ## 4 Keith &lt;NA&gt; guitar Mutating joins left_join(), right_join(), inner_join(), and full_join() are collectively called mutating joins because they add additional columns to a copy of a data set, as does mutate(). Specifying column(s) to join on By default, the mutating join functions will join on the set of columns whose names appear in both data frames. The join functions will match each row in the first data frame to the row in the second data frame that has the same combination of values across the commonly named columns. To override the default, add a by argument to your join function. Pass it the name(s) of the column(s) to join on as a character vector. These names should appear in both data sets. R will join together rows that contain the same combination of values in these columns, ignoring the values in other columns, even if those columns share a name with a column in the other data frame. table1 %&gt;% left_join(table3, by = c(&quot;country&quot;, &quot;year&quot;)) ## # A tibble: 6 x 5 ## country year cases population rate ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745 19987071 745/19987071 ## 2 Afghanistan 2000 2666 20595360 2666/20595360 ## 3 Brazil 1999 37737 172006362 37737/172006362 ## 4 Brazil 2000 80488 174504898 80488/174504898 ## 5 China 1999 212258 1272915272 212258/1272915272 ## 6 China 2000 213766 1280428583 213766/1280428583 Joining when ID names do not match Often an ID variable will appear with a different name in each data frame. For example, the name variable appears as artist in band_instruments2. band_instruments2 ## # A tibble: 3 x 2 ## artist plays ## &lt;chr&gt; &lt;chr&gt; ## 1 John guitar ## 2 Paul bass ## 3 Keith guitar To join by two columns that have different names, pass by a named character vector: each element of the vector should be a pair of names, e.g. c(name1 = &quot;name2&quot;, name4 = &quot;name4&quot;) For each element, Write the name of the column that appears in the first data frame Write an equals sign Write the name of the matching column that appears in the second data set. Only the second name needs to be surrounded with quotation marks. The join will match the corresponding columns across data frames. band_members %&gt;% left_join(band_instruments2, by = c(name = &quot;artist&quot;)) ## # A tibble: 3 x 3 ## name band plays ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Mick Stones &lt;NA&gt; ## 2 John Beatles guitar ## 3 Paul Beatles bass R will use the column name(s) from the first data set in the result. Suffixes Joins will append the suffixes .x and .y to any columns that have the same name in both data sets but are not used to join on. The columns from the first data set are suffixed with .x, the columns from the second with .y. table4a %&gt;% left_join(table4b, by = &quot;country&quot;) ## # A tibble: 3 x 5 ## country `1999.x` `2000.x` `1999.y` `2000.y` ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 745 2666 19987071 20595360 ## 2 Brazil 37737 80488 172006362 174504898 ## 3 China 212258 213766 1272915272 1280428583 To use different suffixes, supply a character vector of length two as a suffix argument. table4a %&gt;% left_join(table4b, by = &quot;country&quot;, suffix = c(&quot;_cases&quot;, &quot;_pop&quot;)) ## # A tibble: 3 x 5 ## country `1999_cases` `2000_cases` `1999_pop` `2000_pop` ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 745 2666 19987071 20595360 ## 2 Brazil 37737 80488 172006362 174504898 ## 3 China 212258 213766 1272915272 1280428583 4.22 Find rows that have a match in another data set You want to find the rows in one data frame that have a match in a second data frame. By match, you mean that both rows refer to the same observation, even if they include different measurements. Your data is structured in such a way that you can match rows by the values of one or more ID columns that appear in both data frames. For example, you would like to return the rows of band_members that have a corresponding row in band_instruments. The new data frame will be a reduced version of band_members that does not contain any new columns. band_members ## # A tibble: 3 x 2 ## name band ## &lt;chr&gt; &lt;chr&gt; ## 1 Mick Stones ## 2 John Beatles ## 3 Paul Beatles band_instruments ## # A tibble: 3 x 2 ## name plays ## &lt;chr&gt; &lt;chr&gt; ## 1 John guitar ## 2 Paul bass ## 3 Keith guitar Solution band_members %&gt;% semi_join(band_instruments, by = &quot;name&quot;) ## # A tibble: 2 x 2 ## name band ## &lt;chr&gt; &lt;chr&gt; ## 1 John Beatles ## 2 Paul Beatles Discussion semi_join() returns only the rows of the first data frame that have a match in the second data frame. A match is a row that would be combined with the first row by a mutating join. This makes semi_join() a useful way to preview which rows will be retained by a mutating join. semi_join() uses the same syntax as mutating joins. Learn more in Specifying column(s) to join on and Joining when ID names do not match. Filtering joins semi_join() and anti_join() (see below) are called filtering joins because they filter a data frame to only those rows that meet a specific criteria, as does filter(). Unlike mutating joins, filtering joins do not add columns from the second data frame to the first. Instead, they use the second data frame to identify rows to return from the first. When you need to filter on a complicated set of conditions, filtering joins can be more effective than filter(): use tribble() to create a data frame to filter against with a filtering join. 4.23 Find rows that do not have a match in another data set You want to find the rows in one data frame that do not have a match in a second data frame. By match, you mean that both rows refer to the same observation, even if they include different measurements. Your data is structured in such a way that you can match rows by the values of one or more ID columns that appear in both data frames. For example, you would like to return the rows of band_members that do not have a corresponding row in band_instruments. The new data frame will be a reduced version of band_members that does not contain any new columns. band_members ## # A tibble: 3 x 2 ## name band ## &lt;chr&gt; &lt;chr&gt; ## 1 Mick Stones ## 2 John Beatles ## 3 Paul Beatles band_instruments ## # A tibble: 3 x 2 ## name plays ## &lt;chr&gt; &lt;chr&gt; ## 1 John guitar ## 2 Paul bass ## 3 Keith guitar Solution band_members %&gt;% anti_join(band_instruments, by = &quot;name&quot;) ## # A tibble: 1 x 2 ## name band ## &lt;chr&gt; &lt;chr&gt; ## 1 Mick Stones Discussion anti_join() returns only the rows of the first data frame that do not have a match in the second data frame. A match is a row that would be combined with the first row by a mutating join. This makes ant_join() a useful way to debug a mutating join. anti_join() provides a useful way to check for typos that could interfere with a mutating join; these rows will not have a match in the second data frame (assuming that the typo does not also appear in the second data frame). anti_join() also highlights entries that are coded in different ways across data frames, such as &quot;North_Carolina&quot; and &quot;North Carolina&quot;. anti_join() uses the same syntax as mutating joins. Learn more in Specifying column(s) to join on and Joining when ID names do not match. Along with semi_join(), anti_join() is one of the two Filtering joins. Or one that can be made the same length with R’s recycling rules, e.g. a vector of length one.↩ summarise() will return a larger tibble if you pair it with group_by().↩ Attributes are metadata associated with a data structure. R can see an object’s attributes, but users typically cannot.↩ I made this data frame with the code sepals &lt;- iris %&gt;% group_by(Species) %&gt;% summarise(lengths = list(Sepal.Length))↩ "],
["transform-lists-and-vectors.html", "5 Transform Lists and Vectors What you should know before you begin 5.1 Extract an element from a list 5.2 Determine the type of a vector 5.3 Map a function to each element of a vector", " 5 Transform Lists and Vectors This chapter includes the following recipes: Extract an element from a list Determine the type of a vector Map a function to each element of a vector What you should know before you begin A vector is a one dimensional array of elements. Vectors are the basic building blocks of R. Almost all data in R is stored in a vector, or even a vector of vectors. A list is a recursive vector: a vector that can contain another vector or list in each of its elements. Lists are one of the most flexible data structures in R. As a result, they are used as a general purpose glue to hold objects together. You will find lists disguised as model objects, data frames, list-columns within data frames, and more. Data frames are a sub-type of list. Each column of a data frame is an element of the list that the data frame is built around. More than any other part of R, lists demonstrate how a programming language can appear different to beginners than to experts. Seasoned R programmers do not distinguish between lists and vectors because the two are equivalent: a list is a type of vector. However, a beginner who uses R for data science will quickly see that lists behave differently than other types of vectors. First, many R functions will not accept lists as input, even though they accept other types of vectors. Second, when you subset a list with [ ] to extract the value of one of its elements, R will give you a new list of length one that contains the value as its first element. This poses a problem if you want to pass that value to a function that does not accept lists as input (solve that problem with this recipe). To respect this difference, I try to be clear when talking about vectors that are not lists. This introduces a new problem: when you speak about R, it is difficult to distinguish between vectors that are lists and vectors that are not lists. Whenever the difference matters, I’ll call the first set of vectors lists and the second set of vectors data vectors5. I’ll refer to the superset that includes both lists and data vectors as vectors. Data vectors come in six atomic types: double, integer logical, character, complex, and raw. Every element in a data vector must be the same type of data as the vector (if you try to put a different type of data into an atomic vector, R will coerce the data’s type to match the vector). R also contains an S3 class system that builds classes like factors and date-times on top of the atomic types. You don’t need to understand R’s types and classes to use R or this cookbook, but you should know that R will recognize different types of data and treat them accordingly. This chapter focuses on both lists and data vectors, but it only features recipes that work with the structure of a list or data vector. The chapters that follow will contain recipes that work with the types of data stored in a data vector. 5.1 Extract an element from a list You want to return the value of an element of a list as it is, perhaps to use in a function. You do not want the value to come embedded in a list of length one. Solution # returns the element named x in state.center state.center %&gt;% pluck(&quot;x&quot;) ## [1] -86.7509 -127.2500 -111.6250 -92.2992 -119.7730 -105.5130 -72.3573 ## [8] -74.9841 -81.6850 -83.3736 -126.2500 -113.9300 -89.3776 -86.0808 ## [15] -93.3714 -98.1156 -84.7674 -92.2724 -68.9801 -76.6459 -71.5800 ## [22] -84.6870 -94.6043 -89.8065 -92.5137 -109.3200 -99.5898 -116.8510 ## [29] -71.3924 -74.2336 -105.9420 -75.1449 -78.4686 -100.0990 -82.5963 ## [36] -97.1239 -120.0680 -77.4500 -71.1244 -80.5056 -99.7238 -86.4560 ## [43] -98.7857 -111.3300 -72.5450 -78.2005 -119.7460 -80.6665 -89.9941 ## [50] -107.2560 Discussion pluck() comes in the purrr package and does the equivalent of [[ subsetting. If you pass pluck() a character string, pluck() will return the element whose name matches the string. If you pass pluck() an integer n, pluck() will return the nth element of the list. Pass multiple arguments to pluck() to subset multiple times. pluck() will subset the result of each argument with the argument that follows, e.g. library(repurrrsive) sw_films %&gt;% pluck(7, &quot;title&quot;) ## [1] \"The Force Awakens\" 5.2 Determine the type of a vector You want to know the type of a vector. Solution typeof(letters) ## [1] \"character\" Discussion R vectors can be one of six atomic types, or a list. typeof() provides a useful way to check which type of vector you are working with. This is useful, for example, when you want to match a function’s output to an appropriate map function (below). 5.3 Map a function to each element of a vector You want to apply a function separately to each element in a vector and then combine the results into a single object. This is similar to what you might do with a for loop, or with the apply family of functions. For example, got_chars is a list of 30 sublists. You want to compute the length() of each sublist. Solution library(repurrrsive) got_chars %&gt;% map(length) ## [[1]] ## [1] 18 ## ## [[2]] ## [1] 18 ## ## [[3]] ## [1] 18 ## ## [[4]] ## [1] 18 ## ## [[5]] ## [1] 18 ## ## [[6]] ## [1] 18 ## ## [[7]] ## [1] 18 ## ## [[8]] ## [1] 18 ## ## [[9]] ## [1] 18 ## ## [[10]] ## [1] 18 ## ## [[11]] ## [1] 18 ## ## [[12]] ## [1] 18 ## ## [[13]] ## [1] 18 ## ## [[14]] ## [1] 18 ## ## [[15]] ## [1] 18 ## ## [[16]] ## [1] 18 ## ## [[17]] ## [1] 18 ## ## [[18]] ## [1] 18 ## ## [[19]] ## [1] 18 ## ## [[20]] ## [1] 18 ## ## [[21]] ## [1] 18 ## ## [[22]] ## [1] 18 ## ## [[23]] ## [1] 18 ## ## [[24]] ## [1] 18 ## ## [[25]] ## [1] 18 ## ## [[26]] ## [1] 18 ## ## [[27]] ## [1] 18 ## ## [[28]] ## [1] 18 ## ## [[29]] ## [1] 18 ## ## [[30]] ## [1] 18 Discussion map() takes a vector to iterate over (here supplied by the pipe) followed by a function to apply to each element of the vector, followed by any arguments to pass to the function when it is applied to the vector. Pass the function name to map() without quotes and without parentheses. map() will pass each element of the vector one at a time to the first argument of the function. If your function requires additional arguments to do its job, pass the arguments to map(). map() will forward these arguments in order, with their names, to the function when map() runs the function. got_chars %&gt;% map(keep, is.numeric) ## [[1]] ## [[1]]$id ## [1] 1022 ## ## ## [[2]] ## [[2]]$id ## [1] 1052 ## ## ## [[3]] ## [[3]]$id ## [1] 1074 ## ## ## [[4]] ## [[4]]$id ## [1] 1109 ## ## ## [[5]] ## [[5]]$id ## [1] 1166 ## ## ## [[6]] ## [[6]]$id ## [1] 1267 ## ## ## [[7]] ## [[7]]$id ## [1] 1295 ## ## ## [[8]] ## [[8]]$id ## [1] 130 ## ## ## [[9]] ## [[9]]$id ## [1] 1303 ## ## ## [[10]] ## [[10]]$id ## [1] 1319 ## ## ## [[11]] ## [[11]]$id ## [1] 148 ## ## ## [[12]] ## [[12]]$id ## [1] 149 ## ## ## [[13]] ## [[13]]$id ## [1] 150 ## ## ## [[14]] ## [[14]]$id ## [1] 168 ## ## ## [[15]] ## [[15]]$id ## [1] 2066 ## ## ## [[16]] ## [[16]]$id ## [1] 208 ## ## ## [[17]] ## [[17]]$id ## [1] 216 ## ## ## [[18]] ## [[18]]$id ## [1] 232 ## ## ## [[19]] ## [[19]]$id ## [1] 238 ## ## ## [[20]] ## [[20]]$id ## [1] 339 ## ## ## [[21]] ## [[21]]$id ## [1] 529 ## ## ## [[22]] ## [[22]]$id ## [1] 576 ## ## ## [[23]] ## [[23]]$id ## [1] 583 ## ## ## [[24]] ## [[24]]$id ## [1] 60 ## ## ## [[25]] ## [[25]]$id ## [1] 605 ## ## ## [[26]] ## [[26]]$id ## [1] 743 ## ## ## [[27]] ## [[27]]$id ## [1] 751 ## ## ## [[28]] ## [[28]]$id ## [1] 844 ## ## ## [[29]] ## [[29]]$id ## [1] 954 ## ## ## [[30]] ## [[30]]$id ## [1] 957 5.3.0.0.1 The map family of functions map() is one of ten similar functions provided by the purrr package that together form a family of functions. Each member of the map family applies a function to a vector in the same iterative way; but each member returns the results in a different type of data structure. Function Returns map A list map_chr A character vector map_dbl A double (numeric) vector map_df A data frame (map_df does the equivalent of map_dfr) map_dfr A single data frame made by row-binding the individual results6 map_dfc A single data frame made by column-binding the individual results7 map_int An integer vector map_lgl A logical vector walk The original input (returned invisibly) 5.3.0.1 How to choose a map function To map a function over a vector, consider what type of output the function will produce. Then pick the map function that returns that type of output. This is a general rule that will return sensible results. For example, the length() function returns an integer, so you would map length() over got_chars with map_int(), which returns the results as an integer vector. got_chars %&gt;% map_int(length) ## [1] 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 ## [24] 18 18 18 18 18 18 18 walk() returns the original vector invisibly (so you can pipe the result to a new function). walk() is intended to be used with functions like plot() or print(), which execute side effects but do not return an object to pass on. 5.3.0.1.1 Map shorthand syntax Map functions recognize two syntax shorthands. If your vector is a list of sublists, you can extract elements from the sublists by name or position, e.g. got_chars %&gt;% map_chr(&quot;name&quot;) ## [1] \"Theon Greyjoy\" \"Tyrion Lannister\" \"Victarion Greyjoy\" ## [4] \"Will\" \"Areo Hotah\" \"Chett\" ## [7] \"Cressen\" \"Arianne Martell\" \"Daenerys Targaryen\" ## [10] \"Davos Seaworth\" \"Arya Stark\" \"Arys Oakheart\" ## [13] \"Asha Greyjoy\" \"Barristan Selmy\" \"Varamyr\" ## [16] \"Brandon Stark\" \"Brienne of Tarth\" \"Catelyn Stark\" ## [19] \"Cersei Lannister\" \"Eddard Stark\" \"Jaime Lannister\" ## [22] \"Jon Connington\" \"Jon Snow\" \"Aeron Greyjoy\" ## [25] \"Kevan Lannister\" \"Melisandre\" \"Merrett Frey\" ## [28] \"Quentyn Martell\" \"Samwell Tarly\" \"Sansa Stark\" got_chars %&gt;% map_chr(3) ## [1] \"Theon Greyjoy\" \"Tyrion Lannister\" \"Victarion Greyjoy\" ## [4] \"Will\" \"Areo Hotah\" \"Chett\" ## [7] \"Cressen\" \"Arianne Martell\" \"Daenerys Targaryen\" ## [10] \"Davos Seaworth\" \"Arya Stark\" \"Arys Oakheart\" ## [13] \"Asha Greyjoy\" \"Barristan Selmy\" \"Varamyr\" ## [16] \"Brandon Stark\" \"Brienne of Tarth\" \"Catelyn Stark\" ## [19] \"Cersei Lannister\" \"Eddard Stark\" \"Jaime Lannister\" ## [22] \"Jon Connington\" \"Jon Snow\" \"Aeron Greyjoy\" ## [25] \"Kevan Lannister\" \"Melisandre\" \"Merrett Frey\" ## [28] \"Quentyn Martell\" \"Samwell Tarly\" \"Sansa Stark\" These do the equivalent of got_chars %&gt;% map_chr(pluck, &quot;name&quot;) got_chars %&gt;% map_chr(pluck, 3) You can use ~ and .x to map with expressions instead of functions. To turn a pice of code into an expression to map, first place a ~ at the start of the code. Then use .x as a pronoun for the value that map should supply from the vector to map over. The map function will iteratively pass each element of your vector to the .x in the expression and then run the expression. An expression like this: got_chars %&gt;% map_lgl(~length(.x) &gt; 0) becomes the equivalent of got_chars %&gt;% map_lgl(function(x) length(x) &gt; 0) Expressions provide an easy way to map over a function argument that is not the first. if you’re an R afficianado, data vectors include both atomic vectors and the S3 classes built upon them, like factors and dates and times↩ These results should themselves be data frames. In other words, the function that is mapped should return a data frame.↩ These results should themselves be data frames. In other words, the function that is mapped should return a data frame.↩ "],
["transform-strings.html", "6 Transform Strings", " 6 Transform Strings "],
["transform-factors.html", "7 Transform Factors", " 7 Transform Factors "],
["transform-dates-and-times.html", "8 Transform Dates and Times", " 8 Transform Dates and Times "]
]
